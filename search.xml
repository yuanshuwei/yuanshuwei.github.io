<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见shell</title>
      <link href="/shell-common/"/>
      <url>/shell-common/</url>
      
        <content type="html"><![CDATA[<p>常见shell</p><a id="more"></a><ul><li><p>文件检索: find</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find ~ -name &quot;build.sh&quot;　#　精确查找</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find ~ -name &quot;build.*&quot;　# 通配符</span><br><span class="line"></span><br><span class="line">find ~ -iname &quot;build.sh&quot;  # 忽略大小写</span><br><span class="line"></span><br><span class="line">man find</span><br></pre></td></tr></table></figure></li><li><p>文件内容检索: grep</p></li><li><p>grep [options] pattern file</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;moo&quot; target* # 查询包含内容&quot;moo&quot;并且文件名以target开头的文件和目标字段串所在的行的内容</span><br></pre></td></tr></table></figure><ul><li><code>grep &quot;ss&quot; ss.log</code>  查找包含你指定内容的行，并打印你呢</li><li><code>grep -o</code> 只显示想要的数据部分</li><li><code>grep -v</code> 过滤掉目标数据</li></ul></li><li><p>管道操作符 |  输出作为后面的输入    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ | grep &quot;target&quot;</span><br></pre></td></tr></table></figure></li><li><p>文件呢内容的统计: awk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk [options] &apos;cmd&apos; file ＃ 特别适合表格类数据，统计等</span><br><span class="line">awk &apos;&#123;print $1,$4&#125;&apos; netstat.txt #打印第一行和第四行, awk默认以空格分割</span><br></pre></td></tr></table></figure></li><li><p>批量替换文本内容: sed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;s/^Str/String/&apos; xx.java #Str开头的Str替换为String</span><br><span class="line">sed -i &apos;/\.$/\;/&apos; xx.java #.结尾的替换为;</span><br><span class="line">sed -i &apos;/Jack/me/g&apos; xx.java ＃Jack替换成me，g是整行替换</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring ioc aop</title>
      <link href="/spring-ioc/"/>
      <url>/spring-ioc/</url>
      
        <content type="html"><![CDATA[<p>spring ioc aop</p><a id="more"></a><h2 id="spring-ioc"><a href="#spring-ioc" class="headerlink" title="spring ioc"></a>spring ioc</h2><p>依赖注入:底层类作为参数传递给上层类，实现下层对上层的控制。<br>依赖注入方式:</p><ul><li>Setter</li><li>Interface</li><li>Constructor</li><li>Annotation</li></ul><p><img src="/images/spring-ioc.png" alt></p><p>通过 <code>BeanDefinition</code> 来描述bean的定义，<code>BeanDefinitionRegistry</code> 的<code>registerBeanDefinition</code> 来注册。<br>Bean最终存在 <code>DefaultListableBeanFactory</code> 中, 用ConcurrentHashMap存储的Bean名称和BeanDefinition</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap(256)</span><br><span class="line">List&lt;String&gt; beanDefinitionNames = new ArrayList(256)</span><br></pre></td></tr></table></figure><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><ul><li>提供ioc的配置机制</li><li>包含Bean的各种定义，便于实例化Bean</li><li>建立Bean之间的依赖关系</li><li>Bean的生命周期的控制</li></ul><h4 id="BeanFactory与ApplicationContext"><a href="#BeanFactory与ApplicationContext" class="headerlink" title="BeanFactory与ApplicationContext"></a>BeanFactory与ApplicationContext</h4><p>BeanFactory是spring的基础设施，面向spring<br>ApplicationContext面向使用spring的开发者  </p><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>继承如下接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver</span><br></pre></td></tr></table></figure></p><ul><li>BeanFactory: 能够管理，装配Bean</li><li>ResourcePatternResolver: 能够加载资源文件</li><li>MessageSource: 能够实现国际化等功能</li><li>ApplicationEventPublisher： 能够注册监听器，实现监听机制</li></ul><h4 id="getBean方法的代码逻辑"><a href="#getBean方法的代码逻辑" class="headerlink" title="getBean方法的代码逻辑"></a>getBean方法的代码逻辑</h4><ul><li>转换beanName</li><li>从缓存种加载实例</li><li>实例化Bean</li><li>检测parentBeanFactory</li><li>初始化依赖的Bean</li><li>创建Bean</li></ul><h4 id="spring-bean的作用域"><a href="#spring-bean的作用域" class="headerlink" title="spring bean的作用域"></a>spring bean的作用域</h4><ul><li>singleton: spring的默认作用域，容器里拥有唯一的bean实例</li><li>prototype: 针对每个getBean请求，容器</li><li>request: 会为每个Http请求创建一个Bean实例</li><li>session: 会为每个session创建一个session实例</li><li>globalSession: 会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效</li></ul><h4 id="spring-bean的生命周期"><a href="#spring-bean的生命周期" class="headerlink" title="spring bean的生命周期"></a>spring bean的生命周期</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ol><li>实例化bean</li><li>Aware(注入Bean ID，BeanFactory和AppCtx)</li><li>BeanPostProcessor(s) <code>postProcessBeforeInitialization</code></li><li>InitializingBean(s). <code>afterPropertiesSet</code></li><li>定制的Bean init 方法</li><li>BeanPostProcessor(s). <code>postProcessAfterInitialzation</code></li><li>Bean初始化完毕</li></ol><h5 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h5><ol><li>若实现了 <code>DisposableBean</code> 接口，则会调用destroy方法</li><li>若配置了 <code>destroy-method</code> 属性, 则会调用其配置的销毁方法</li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>实现: <code>JdkProxy</code> 和 <code>Cglib</code></p><ul><li>由AopProxyFactory根据AdvisedSupport对象的配置来决定</li><li>默认策略如果目标类是接口，则用JdkProxy来实现，否则用后者</li><li>JdkProxy的核心: InvocationHandler接口和Proxy类</li><li>Cglib： 以继承方式动态生成目标类的代理</li><li>JdkPeoxy是Java内部的反射机制实现的， Cglib结果ASM实现</li><li>反射机制在生成类的过程比较高效；ASM在生成类之后的执行过程比较高效</li></ul><p>代理模式: 接口 + 真是实现类 + 代理类</p><h4 id="spring代理模式的实现"><a href="#spring代理模式的实现" class="headerlink" title="spring代理模式的实现"></a>spring代理模式的实现</h4><ul><li>真实实现类的逻辑包含在getBean方法里</li><li>getBean方法返回的实际是Proxy的实例</li><li>Proxy实例是spring通过JDK Proxy或CGLIB动态生成的</li></ul><p>ACID/隔离级别/事务传播</p><blockquote><p><a href="https://www.cnblogs.com/ooo0/p/11029658.html" target="_blank" rel="noopener">参考这个吧</a></p></blockquote><h4 id="事务的传播性"><a href="#事务的传播性" class="headerlink" title="事务的传播性"></a>事务的传播性</h4><table><thead><tr><th>name</th><th>特性</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>spring默认的机制，如果外层有事务则当前事务加入到外层事务，一块提交一块回滚，如果外层没有事务则当前开启一个新事务</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>每次开启一个新事务，同时把外层的事务挂起，当前事务执行完毕后恢复上层事务的执行</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>如果外层有事务则加入该事务，如果不存在也不会新建事务</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>不支持事务，外层事务挂起，执行当前逻辑，恢复外层事务</td></tr><tr><td>PROPAGATION_NEVER</td><td>不支持事务，外层存在事务则直接抛出异常</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>配置了的方法只能在已存在事务的方法调用，如果不存在事务的方法调用，抛出异常</td></tr><tr><td>PROPAGATION_NESTED</td><td>可以保存状态保存点，事务回滚时会回滚到某一个点上，从而避免所有嵌套事务都回滚</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发笔记</title>
      <link href="/concurrent-note/"/>
      <url>/concurrent-note/</url>
      
        <content type="html"><![CDATA[<p>并发笔记<br><a id="more"></a></p><ul><li>线程的状态: 新建、可运行(就绪状态，start后马上进入就绪状态、)、运行、阻塞(比如sleep方法后)、死亡</li><li><a href="https://juejin.im/post/5b4eec7df265da0fa00a118f" target="_blank" rel="noopener">synchronized</a><pre><code>- 底层是通过monitor(监视器锁)对象完成的，通过软件在jvm实现- 同步代码块是 `monitorenter` 和 `monitorexit`完成，同步方法是通过检查`ACC_SYNCHRONIZED`标识符是否被设置- 实现方式是jvm在底层调用操作系统的互斥原语mutex实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。- 其实wait/notify等方法也依赖于monitor对象</code></pre></li><li><a href="/threadlocal/" title="ThreadLocal源码分析">ThreadLocal源码分析</a></li><li><a href="https://www.cnblogs.com/paddix/p/5428507.html" target="_blank" rel="noopener">volatile原理</a><pre><code>- 通过volatile修饰的变量可以保证线程之间的可见性，但并不能保证这多个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果- 可见性:①写变量时，强制刷新到主内存中②修改变量后，强制让其他线程的工作内存中的值失效- 顺序性:指令重排序，通过一组处理器指令，实现对内存操作的顺序限制(理解单例的懒加载的双重锁检查中的新建对象的三个过程)</code></pre></li><li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">CAS</a> / <a href="https://www.jianshu.com/p/fb6e91b013cc" target="_blank" rel="noopener">参考2</a><pre><code>- 比较，如果原始值没有被修改过，则更新成新的目标值；如果这一步的CAS没有成功，那就采用自旋的方式继续进行CAS操作，取出乍一看这也是两个步骤了啊，其实在 `JNI` 里是借助于一个 `CPU指令` 完成的。所以还是原子操作。- `synchronized` 是悲观锁，假设一定会发生冲突，直接加锁操作，比较重； `CAS` 是 乐观锁，假设不会发生冲突，当大声冲突时，进行重试操作； ReenterLock内部的AQS，还是各种Atomic开头的原子类，内部都应用到了CAS- 缺点：ABA问题， 用`AtomicStampedReference`, 它可以通过控制变量值的版本来保证CAS的正确性。/ `循环时间长开销大`</code></pre></li><li><a href="https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70" target="_blank" rel="noopener">AQS</a><pre><code>- 即队列同步器。它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等） </code></pre><ul><li>偏向锁:加锁偏向经常分配到的那个线程</li><li>ReentrantLock（公平锁\非公平锁两种实现)</li><li>线程池分类，关键参数设置<ul><li>ExecutorService的execute和submit:submit有返回值，而execute没有; submit用的Future,call的方式得到返回值 <a href="http://www.jcodecraeer.com/a/chengxusheji/java/2014/0903/1672.html" target="_blank" rel="noopener">链接</a></li></ul></li></ul></li><li>并发的几种实现方式 <a href="https://www.jianshu.com/p/bdac4e8a6839" target="_blank" rel="noopener">111</a><ul><li>任务类实现Runnable接口，在方法Run()里定义任务。</li><li>任务类继承Thread，重写run()方法。</li><li>实现接口Callable并在call()方法里得到线程执行结果。</li></ul></li><li>thread与线程池<ul><li><a href="https://www.cnblogs.com/qifenghao/p/8977378.html" target="_blank" rel="noopener">ThreadLocal 遇上线程池的问题及解决办法</a></li><li>线程池中的线程在任务执行完成后会被复用，所以在线程执行完成时，要对 ThreadLocal 进行清理（清除掉与本线程相关联的 value 对象）。不然，被复用的线程去执行新的任务时会使用被上一个线程操作过的 value 对象，从而产生不符合预期的结果。</li></ul></li><li><a href="https://www.jianshu.com/p/d8cdfd6bc7a4" target="_blank" rel="noopener">线程池参数</a><br>比如coresize 1 maxsize 5　有界队列:<br>先判断当前空闲线程数和coresize的关系，如果超过coresize扔队列，队列满，判断maxsize满没满，没满创建thread,如果满了执行拒绝策略逻辑(jdk自带４种拒绝策略，也可以重写，只要实现RejectExecutionHandler类)<ul><li>阻塞队列<ol><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue：一个具有优先级得无限阻塞队列。</li></ol></li><li>线程池饱和时，线程数大于maxsize,的拒绝策略<ul><li>hreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li><li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ul></li></ul></li></ul><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><p>进程独占程序内存，线程是对进程拆分的多个任务的并发执行；进程是资源分配的最小单位，线程是CPU调度的最小单位。</p><h4 id="Thread的start和run"><a href="#Thread的start和run" class="headerlink" title="Thread的start和run"></a>Thread的start和run</h4><p>start()方法会创建一个新的子线程并启动；run()方法只是一个普通方法的调用</p><h4 id="线程返回值"><a href="#线程返回值" class="headerlink" title="线程返回值"></a>线程返回值</h4><p>通过Callable接口实现，通过FutureTask或线程池获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        String value = &quot;test&quot;;</span><br><span class="line">        System.out.println(&quot;Ready to work&quot;);</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        System.out.println(&quot;work done&quot;);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CallableDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask task = new FutureTask(new MyCallable());</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        if (!task.isDone()) &#123;</span><br><span class="line">            System.out.println(&quot;task has not finished, pleaser wait!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;task return :&quot; + task.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(new MyCallable());</span><br><span class="line">        if (!future.isDone()) &#123;</span><br><span class="line">            System.out.println(&quot;task has not finished, pleaser wait!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>新建、运行(running和ready)、无限期等待、限期等待、阻塞、结束</p><h4 id="sleep和wait"><a href="#sleep和wait" class="headerlink" title="sleep和wait"></a>sleep和wait</h4><p>sleep只让出cpu，不会导致锁行为的变化；wait不仅让出cpu还释放已占有的同步资源锁</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul><li>每个Java对象头存储的锁信息，代码块monitorenter,monitorexit,锁方法，ACC_SYNCHRONIZED标志；</li><li>早期属于重量级锁，原来mutex lock实现，线程切换需要用户态转到核心态，开销很大</li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>AQS实现，可以对获取锁的等待时间进行设置，避免死锁；可以获取各种锁信息；可以灵活实现多路通知；Sync操作Mark Word，lock调用Unsafe类的park()方法</p><h4 id="HashMap-put方法逻辑"><a href="#HashMap-put方法逻辑" class="headerlink" title="HashMap put方法逻辑"></a>HashMap put方法逻辑</h4><ul><li>如果未初始化过，则初始化</li><li>对key求hash，然后计算下标</li><li>如果没有碰撞，直接放入桶中</li><li>如果碰撞了，已链表方式链接到后面</li><li>如果链表长度超过阈值，链表转为红黑树</li><li>如果节点已存在就替换旧值</li><li>如果桶满了就resize(扩容2倍后重排)</li></ul><h4 id="ConccurentHashMap"><a href="#ConccurentHashMap" class="headerlink" title="ConccurentHashMap"></a>ConccurentHashMap</h4><p>CAS+synchronized使锁更细化； 数组+链表+红黑树</p><h4 id="JUC梳理"><a href="#JUC梳理" class="headerlink" title="JUC梳理"></a>JUC梳理</h4><ul><li>collections: Queue,ConcurrentMap,</li><li>executor: Furure,Callable,Executor</li><li>tools: CountDownLatch,CyclicBarrier,Semaphore,Executors,Exchanger</li><li>locks:ReentantLock, Condition,ReadWriteLock,LockSypport</li><li>atomic: AtomicInteger…</li></ul><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><ul><li>ArrayBlockingQueue: 数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue: 链表结构组成的有界/无界阻塞队列</li><li>PriorityBlockingQueue: 支持优先级排序的无界阻塞队列</li><li>DelayQueue: 优先级实现的无界阻塞队列</li><li>SynchronousQueue: 不存储元素的阻塞队列</li><li>LinkedTransferQueue: 链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque: 链表结构组成的双向阻塞队列</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis笔记</title>
      <link href="/redis-note/"/>
      <url>/redis-note/</url>
      
        <content type="html"><![CDATA[<p>redis笔记<br><a id="more"></a></p><h4 id="与Memcache区别"><a href="#与Memcache区别" class="headerlink" title="与Memcache区别"></a>与Memcache区别</h4><ul><li>memcache支持简单数据类型</li><li>不支持持久化</li><li>不支持主从同步</li><li>不支持分片</li><li>Redis数据类型丰富</li><li>支持持久化存储</li><li>支持主从</li><li>支持分片</li></ul><h4 id="Redis很快"><a href="#Redis很快" class="headerlink" title="Redis很快"></a>Redis很快</h4><ul><li>基于内存</li><li>数据结构简单，不设计关联</li><li>单线程处理高并发，多核也可启动多实例</li><li>多路I/O复用模型，非阻塞IO</li></ul><h4 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h4><ul><li>select系统调用</li><li>因地制宜选择IO多路复用函数</li><li>优先选择时间复杂度O(1), O(n)的select作为保底</li><li>基于react设计模式监听IO事件</li></ul><h3 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h3><ul><li><p>String: 二级制安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; set k v</span><br><span class="line">&gt; get k</span><br><span class="line">&gt; incr k</span><br></pre></td></tr></table></figure></li><li><p>Hash: 类似map结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset lilei name &quot;lilei&quot; age 26 title &quot;Senior&quot;</span><br><span class="line">&gt; hget lilei name</span><br><span class="line">&gt; hset lilei title &quot;Pricipal&quot;</span><br></pre></td></tr></table></figure></li><li><p>List： 有序列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; lpush mylist aaa</span><br><span class="line">&gt; lpush mylist bbb</span><br><span class="line">&gt; lpush mylist ccc</span><br><span class="line">&gt; lrange mylist 0 10</span><br><span class="line">1) &quot;ccc&quot;</span><br><span class="line">2) &quot;bbb&quot;</span><br><span class="line">3) &quot;aaa&quot;</span><br></pre></td></tr></table></figure></li><li><p>Set: 不重复的无序集合，哈希表时间，复杂度是O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd myset 111</span><br><span class="line">&gt; sadd myset 222</span><br></pre></td></tr></table></figure></li><li><p>Sorted Set: 按权重排序的不重复集合, 小到大排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd myset 3 aaa</span><br><span class="line">&gt; zadd myset 1 bbb</span><br><span class="line">&gt; zadd myset 2 ccc</span><br><span class="line">&gt; zrangebyscore myset 0 10</span><br></pre></td></tr></table></figure></li></ul><h3 id="海量数据里查询某一前缀的key"><a href="#海量数据里查询某一前缀的key" class="headerlink" title="海量数据里查询某一前缀的key"></a>海量数据里查询某一前缀的key</h3><blockquote><p>摸清边界，数据量</p></blockquote><p>Keys指令对于线上数据量很大，对于内存的消耗和redis服务器都是隐患</p><p><code>scan cursor [pattern] [count]</code></p><ul><li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程</li><li>以0开始新一次的迭代，知道命令返回游标0完成一次遍历</li><li>不保证每次执行都返回某个给定数量的元素，支持模糊查询</li><li>count只是大概的参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan 0 match k1* count 10</span><br></pre></td></tr></table></figure><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>需要解决的问题：</p><ul><li>互斥性: 同一时间只能一个线程获取到锁</li><li>安全性: 锁只能被持有锁的线程删除</li><li>死锁: 过期时间问题，获取到锁宕机问题</li><li>容错: redis部分宕机，需要还能继续获取到锁</li></ul><p>SETNX 解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX K V</span><br></pre></td></tr></table></figure></p><p>不存在则创建成功，已存在则创建失败，v可以存当前线程id或者机器id；<br>还需要设置过期时间， <code>expire k [时间]</code>； 但两个命令不能保证原子性；可能创建成功没设置过期时间就宕机了，此时这个锁一直不能被其他线程获取到。于是redis提供了另外的一个命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set k v [EX second] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><ul><li>EX second: 设置键的过期时间为second秒</li><li>PX milliseconds： 设置键的过期时间是毫秒</li><li>NX： 键不存在时，才对键进行设置操作</li></ul><h3 id="Redis异步队列"><a href="#Redis异步队列" class="headerlink" title="Redis异步队列"></a>Redis异步队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush mylist aaa</span><br><span class="line">&gt; rpush mylist bbb</span><br><span class="line">&gt; rpush mylist ccc</span><br><span class="line">&gt; lpop mylist</span><br><span class="line">&gt; aaa</span><br></pre></td></tr></table></figure><ul><li>缺点: 没有等待队列里有值就直接消费</li><li>弥补: 可以在应用层引入sleep机制去调用LPOP重试</li></ul><p>不用sleep的话，直接用BLPOP，没有消息的时间就阻塞，超时后再返回。 <code>blpop testlist [超时时间]</code></p><h4 id="主题订阅模式，-pub-sub"><a href="#主题订阅模式，-pub-sub" class="headerlink" title="主题订阅模式， pub/sub"></a>主题订阅模式， pub/sub</h4><ul><li>发生消息，接收消息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; subscribe mytopic</span><br><span class="line">&gt; subscribe mytopic</span><br><span class="line">&gt; publish mytopic &quot;hello&quot;</span><br></pre></td></tr></table></figure></li></ul><p>这种无法保证可达，会丢失。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><ul><li>RDB: 快照,每隔一段时间保存当前全量数据，多个文件；速度快文件小，相对容易丢失</li><li>AOF: 保存所有写命令,保存命令；数据不易丢失。文件体积大，恢复时间长</li><li>RDB-AOF混合 持久化方式(redis4.0后)： RDB保存全量数据-AOF保存增量数据</li></ul><p>同时存在AOF和RDB文件，的数据恢复： 重启redis即可。优先加载AOF文件</p><p>###　pipeline</p><ul><li>与linux的管道类似</li><li>redis基于请求响应模式，单个请求处理需要一一应答</li><li>pipeline批量执行指令，节省多次IO往返时间</li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从同步，从从同步。</p><p><strong>全量同步</strong></p><ul><li>slave发送sync命令到master</li><li>master启动一个后台进程,将redis的数据快照保存在文件中</li><li>master把文件发送给slave，slave对AOF文件加载</li></ul><p><strong>增量同步</strong></p><ul><li>master的写命令存在AOF中,　将命令数据写入缓存然后发生给slave</li></ul><h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><ul><li>作用:高性能，高并发；　</li><li>雪崩: 宕机的处理<ul><li>事前：主从复制＋哨兵，redis　cluster维持高可用</li><li>事中，限流，降级，增加本地缓存</li><li>事后: redis持久化，快速恢复数据</li></ul></li><li>redis线程模型:  它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。多个socket,IO多路复用，文件时间分派器，事件处理器</li><li>redis效率高: 纯内存操作,IO多路复用的非阻塞IO,Ｃ语言实现,单线程避免上下文切换问题,单线程处理高并发，多核也可启动多实例</li><li>数据类型: string,hash,list,set,sorted sort</li><li>过期策略: 定时删除(默认100ms抽一部分有过期时间的key)＋惰性删除(用到时检查)＋内存淘汰机制(常用LRU, 空间不足时，删除最近最少使用的key)</li><li>持久化方式: RDB和AOF,RDB周期性保存全量的数据备份，AOF保存全部的写命令。<ul><li><strong>RDB</strong>适合做冷备份，对外读写服务影响小，保持高性能。但每隔5分钟甚至更长会导致丢失数据。　</li><li><strong>对于AOF</strong>：每个１秒执行，适合误删除的紧急恢复，同一份数据AOF更大，恢复较慢，命令回访恢复数据，不够健壮。</li><li><strong>一般的方式</strong>:综合两种方式，AOF保证数据的不丢失，作为第一选择；RDB做不同程度的冷备份。</li></ul></li><li>主从复制: <ul><li><strong>第一次从连接主时</strong>: 从发送命令<code>PSYNC</code>,主生成RDB文件发送给从，并在内存中缓存RDB生成后的所有写操作，当从加载完RDB文件，主将缓存中的写命令发送给从,完成数据的同步。</li><li><strong>主从复制断点续传</strong>: redis2.8以后，主节点在内存中维护一个backlog,主和从都会保存一个replica offse还有一个run id,offset就是保存在backlog中,如果主从断开连接，从会让主从上次replica offset继续复制</li></ul></li><li>哨兵: <ul><li><strong>作用</strong>: 集群监控(监控主从节点是否正常)、消息通知(每个redis故障则通知给管理员)、故障转移(主从切换)、配置中心(故障发生，通知cilent客端新的主节点的地址)。哨兵本身也是分布式的。　</li><li><strong>自动发现机制</strong>: 哨兵通过sub/pub,每个哨兵都向<code>__sentinel__:hello</code>这个channel发消息，同步自己的host,ip,runid还有对master的监控。来感知其他哨兵的存在，互相同步各自监控信息和配置信息。</li><li><strong>主从切换步骤</strong>: 每个哨兵ping master,超过指定时间就认为宕机，此时是主观宕机；当哨兵集群中超过一半都认为master宕机了，此时到达了客观宕机，可以进行主从切换　</li><li><strong>选举算法</strong>: ①跟master断开时长②slave优先级③复制offset(复制数据更多的那个)④run id(大小排序)</li></ul></li><li>集群(redis cluster): <ul><li>16384个槽，哪个master负责哪个槽用户可以指定。所有键都会被直派到具体的槽:CRC64(key)%16384,也就是key的校验和对16384取余得到</li><li>每个节点有自己看来整个集群的状态，包括某个槽对应哪个节点</li><li>当客户端向集群中任一节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽（CRC16(key) &amp; 16383），并检查这个槽是否指派给了自己： <ul><li>·如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。 </li><li>·如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令。</li></ul></li><li><a href="https://blog.csdn.net/yejingtao703/article/details/78484151" target="_blank" rel="noopener">图解redis集群原理</a></li><li><a href="https://whetherlove.github.io/2018/10/07/Redis%E9%9B%86%E7%BE%A4-Cluster%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">原理</a></li><li><a href="http://shanks.leanote.com/post/Redis-Cluster" target="_blank" rel="noopener">原理2</a></li></ul></li></ul><p>手写LRU　<a href="https://www.cnblogs.com/WJ5888/p/4371647.html" target="_blank" rel="noopener">参考</a><br><figure class="highlight plain"><figcaption><span>offse还有一个run id,offset </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line">    private final int CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 传递进来最多能缓存多少数据</span><br><span class="line">     *</span><br><span class="line">     * @param cacheSize 缓存大小</span><br><span class="line">     */</span><br><span class="line">    public LRUCache(int cacheSize) &#123;</span><br><span class="line">        // true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span><br><span class="line">        super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        // 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span><br><span class="line">        return size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql笔记</title>
      <link href="/mysql-note/"/>
      <url>/mysql-note/</url>
      
        <content type="html"><![CDATA[<p>mysql笔记<br><a id="more"></a></p><h2 id="mysql基础架构"><a href="#mysql基础架构" class="headerlink" title="mysql基础架构"></a>mysql基础架构</h2><p><img src="/images/mysql-construct.png" alt></p><ul><li>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li></ul><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="redo-log-innoDB特有"><a href="#redo-log-innoDB特有" class="headerlink" title="redo log(innoDB特有)"></a>redo log(innoDB特有)</h3><ul><li>当一条记录需要更新的时候，innoDB先把记录写到redo log，并更新内存，这个时候更新就算完成了，innoDB会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是系统空闲的时候</li><li>redo log是固定大小的，从头开始写，写到末尾又回到开头循环写。在这个环上一个标记写位置的指针，一个标记当前擦除位置的指针，当快追上的时候就开始移动指针删除数据。</li><li>有了redo log，就可以保证数据库发生异常重启，之前的记录不会丢失，这个能力称为<strong>crash-safe</strong></li></ul><h3 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog(归档日志)"></a>binlog(归档日志)</h3><ul><li>mysql server层实现的</li><li>redo log是物理日志，</li></ul><h4 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h4><ul><li>写入redo log处理prepare阶段</li><li>写入bin log 提交事务，处于commit状态</li></ul><h4 id="为什么两段提交？"><a href="#为什么两段提交？" class="headerlink" title="为什么两段提交？"></a>为什么两段提交？</h4><p>使得bin log与 redo log一致<br>redo log: 少一条的话，更新数据库重启的恢复<br>bin log: 影响数据库备份的数据</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><ol><li>事务特性: (ACID)  原子性、一致性、隔离性、持久性</li></ol></li><li><ol start="2"><li>多事务同时执行，可能出现的问题: 脏读、不可重复读、幻读</li></ol></li><li><ol start="3"><li>事务隔离级别(多个事务执行间的问题): 读未提交、读提交、可重复读、串行化</li></ol></li><li><ol start="4"><li>不同隔离级别的区别: </li></ol><ul><li><strong>读未提交</strong>: 一个事务还未提交，他所做的修改可以被其他事务看到(没有视图概念)</li><li><strong>读提交</strong>: 一个事务提交以后，他所做的修改才可以被其他事务看到(每个语句执行时创建的视图)</li><li><strong>可重复读</strong>: 一个事务执行过程看到的数据是一致的(视图实现),未提交的更改对其他事务不可见。(事务启动时创建视图实现)</li><li><strong>串行化</strong>: 对应一个记录加读写锁，出现冲突时，后访问的事务必须等前一个事务执行完成才能继续执行(加锁实现)</li></ul></li><li><ol start="5"><li>配置方法: 启动参数transaction-isolation</li></ol></li><li><ol start="6"><li>事务隔离的实现: 每条记录更新时都同时记录一个回滚操作，同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制(MVCC)</li></ol></li><li><ol start="7"><li>回滚日志什么时候删除: 系统判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除</li></ol></li><li><ol start="8"><li>什么时候不需要了？当系统没有比这个回滚日志更早的read-view的时候</li></ol></li><li><ol start="9"><li>为什么尽量不要使用长事务？长事务意味在系统里存在很老的事务视图，事务提交之前都会保存，导致占用大量存储空间，长事务还占用锁资源，可能拖垮库</li></ol></li><li><ol start="10"><li>多事务同时执行可能出现的问题 <a href="https://uule.iteye.com/blog/1109647" target="_blank" rel="noopener">参考</a></li></ol><ul><li><strong>脏读</strong>: 一个事务修改了数据还未提交，另一个事务读取并使用了这个数据。当第一个事务回滚，另一个事务使用的数据就是脏数据(发生在<code>读未提交</code>)</li><li><strong>不可重复读</strong>: 一个事务内多次读同一个数据，两次读之间数据被另一个事务修改，导致这两次读到的数据不一致。</li><li><strong>幻读</strong>: 事务1对所有数据行执行修改，同时事务2添加了一条数据。事务1发现自己并没有实现全部数据的修改，好像发生了幻觉。(解决: 一个事务完成了处理前，其他事务不可以插入数据)<blockquote><p>mysql默认是可重复读，oracle默认是读提交</p></blockquote></li></ul></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h4 id="数据结构的考虑"><a href="#数据结构的考虑" class="headerlink" title="数据结构的考虑:"></a>数据结构的考虑:</h4><ul><li>hash: <ul><li>类似数组+链表，key的hash值确定在数组(桶)中的位置，出现hash冲突时，拉链。但这种对于范围查询不适用，需要全部扫描，比较适合<strong>等值查询</strong></li></ul></li><li>有序数组: <ul><li>查询利用二分查询,时间复杂度是O(log(N)); 也适用范围查询。但插入元素，需要移动后面的全部元素，效率很低。<strong>适合静态存储引擎，不会修改数据了</strong></li></ul></li><li>二叉树: <ul><li>特点是，每个节点的左二子小于这个节点，右二子大于当前节点；这样查询的效率是O(log(N)),为了维持这个查询复杂度，需要保持这棵树是平衡二叉树，所以更新时间复杂度也是O(log(N))。</li><li>实际索引使用的是多叉树(一个树有多个节点),原因是索引需要写磁盘，尽量要减少数据块的寻址，让树高小一点。 N叉树的N取决于数据块的大小。</li></ul></li></ul><h4 id="索引字段问题"><a href="#索引字段问题" class="headerlink" title="索引字段问题"></a>索引字段问题</h4><ul><li>主键索引(聚簇索引，叶子节点存的是整行数据)、非主键索引(二级索引，叶子节点存的是主键，所以还需要再查询一次主键索引的树)；<strong>我们应尽量使用主键查询</strong>。</li><li>而考虑占用空间，比如要用身份证号还是自增id做主键，显然主键越小，普通索引的叶子节点就越小，普通索引的占用空间也越小，所以自增主键更适合。</li><li>索引定位到page，page内部是一个有序数组，通过二分法查询。<blockquote><p>通过普通索引查询到主键，再去主键索引树查询,叫做回表。</p></blockquote></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>持有对方需要的锁，并请求对应资源。解决: 执行死锁的回滚事务。对于InnoDB将持有最少行级排他锁的事务回滚</p><h4 id="一些索引"><a href="#一些索引" class="headerlink" title="一些索引"></a>一些索引</h4><ul><li>覆盖索引: 如果查询条件使用的是普通索引(或者是联合索引的最左原则)，查询结果是联合索引的字段或主键，不用回表，直接返回结果，减少IO磁盘读写读取正行数据。</li><li>最左前缀: 联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</li><li>联合索引: 根据创建联合索引的顺序，以最左原则进行where检索，比如(age,name)以age=1或者age=1 and name=’张三’可以使用索引，单以name=’张三’不会使用索引，考虑存储空间问题，需要根据业务需求，将查找频繁的数据进行靠左创建索引。</li><li>索引下推: like ‘hello%’ and age &gt;10检索，mysql5.6之前，会对匹配的数据进行回表查询，5.6以后，回先过滤掉age&lt;10的数据，再进行回表查询，减少回表率，提升检索速度。</li><li>为什么用B+存储索引?(演变过程) <a href="https://juejin.im/entry/5bc1ea0a5188255c2f424209" target="_blank" rel="noopener">参考</a><ul><li>hash: 查询很快，适合固定值查询。不适合范围查询。</li><li>有序数组: 查询和范围查询都很快，插入需要移动后面全部元素，效率较低。</li><li>二叉搜索树: 存在极端情况，出现链表结构，搜索效率较低</li><li>平衡二叉树: 解决了上面的问题，但对于索引大部分节点存在磁盘，每个节点是非连续的空间，每个节点的寻址操作是影响搜索速度的关键。基于此尽量需要减小树的高度</li><li>B树与B+树: 每个节点多放一些数据，对应数据库读取的最小单位页<ul><li>B+树跟B树不同，B+树叶子节点冗余了所有非叶子节点的数据</li><li>B+树每个叶子节点增加了指向相邻的节点的指针</li><li>优点:<ul><li>非叶子节点不会带上指向记录的指针，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点</li><li>叶子节点间有序的链表，有利于范围查找。</li></ul></li></ul></li></ul></li></ul><h2 id="全局锁、表级锁、行级锁"><a href="#全局锁、表级锁、行级锁" class="headerlink" title="全局锁、表级锁、行级锁"></a>全局锁、表级锁、行级锁</h2><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁:"></a>全局锁:</h4><ul><li>读整个数据库实例加锁。</li><li>mysql提供加锁全局读锁的方法:Flush tables with read lock(FTWRL)这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句会被阻塞</li><li>使用场景: 全库逻辑备份</li><li>风险:<ul><li>如果在主库备份，在备份期间不能更新，业务停摆</li><li>如果在从库备份，备份期间不能同步binlog，导致主从延迟，官方自带逻辑备份工具mysqldump,当mysqldump使用参数–single-transaction的时候，会启动一个事务，确保拿到一致性视图，而由于MVCC的支持，这个过程中数据是可以正常更新的</li></ul></li><li>一致性读是好，但前提是引擎要支持隔离级别</li><li>如果全库只读为什么不使用set global readonly=true的方式？<ul><li>readonly在有些系统被用来其他逻辑，比如判断主备库，所以修改的话影响较大</li><li>异常机制有差异，FTWRL在发生异常时，会释放全局锁，readonly一直保持</li></ul></li></ul><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ul><li>mysql有两种表级锁:一种是表锁；一种是元数据锁(meta data lock, MDL)</li><li>MDL:不需要显示使用，访问一个表时字段加上</li><li>读写锁互斥，写写锁互斥，读读锁不互斥</li><li>MDL会直到事务提交才会释放，在做表结构变更是，一定要小心不要导致阻塞线上查询和更新 </li><li>表级锁限制只能当前线程的操作，比如，线程A执行lock t1 read,t2 write ，则其他线程写t1。读写t2都会被阻塞</li></ul><h4 id="乐观锁与悲观锁-参考"><a href="#乐观锁与悲观锁-参考" class="headerlink" title="乐观锁与悲观锁 参考"></a>乐观锁与悲观锁 <a href="https://www.jianshu.com/p/f5ff017db62a" target="_blank" rel="noopener">参考</a></h4><ul><li>悲观锁: 假设一定会发生冲突，所以每次拿数据之前都要加锁 (select for update 锁定当前行)</li><li>乐观锁: 每次拿数据都认为别人不会修改，只在提交时检查数据是不是已经被别人更新过了，乐观锁适用于读多写少的场景，这样可以提高吞吐量。(cas方式,字段值没有被其他线程修改，则更新操作)<ul><li>版本字段控制: 增加一个数字类型的字段’version’,每次更新加1。 CAS方式实现</li><li>使用时间戳，CAS，比较时间</li></ul></li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><ul><li>单表数据量太大，影响sql执行性能</li></ul><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><ul><li>并发量很高，单库并发量最好控制在每秒1000左右</li></ul><h3 id="中间件推荐"><a href="#中间件推荐" class="headerlink" title="中间件推荐"></a>中间件推荐</h3><ul><li>Sharding-jdbc， 当当开源，client层方案</li><li>Mycat，基于阿里的Cobar改造，proxy层解决方案</li></ul><h3 id="水平拆分与垂直拆分"><a href="#水平拆分与垂直拆分" class="headerlink" title="水平拆分与垂直拆分"></a>水平拆分与垂直拆分</h3><ul><li>水平: 就是把一个库的一个表数据弄到多个库的多个表中去，每个库的表结构一样，只不过每个表数据不同</li><li>垂直拆分: 表级别，将表字段拆分到不同的表中，单表最好控制在200万左右</li></ul><h3 id="两种分库分表方式"><a href="#两种分库分表方式" class="headerlink" title="两种分库分表方式"></a>两种分库分表方式</h3><ul><li>按range，比如时间范围,但会有近期热点访问问题</li><li>按每个字段，比如hash一下，分布均匀；会有扩容时的重新hash问题</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ul><li>从库到主库来去binlog，然后在本地执行sql语句</li><li>半同步复制: 主库写入binlog以后，强制立即给从库，从库写完，至少一个返回ack，才算写成功</li></ul><h2 id="主从同步延迟问题"><a href="#主从同步延迟问题" class="headerlink" title="主从同步延迟问题"></a>主从同步延迟问题</h2><ul><li>分库，降低主库的并发</li><li>重写代码，尽量不要写完马上查询</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019面经</title>
      <link href="/interview-experience-2019/"/>
      <url>/interview-experience-2019/</url>
      
        <content type="html"><![CDATA[<p>面经整理～～<br><a id="more"></a></p><h2 id="58金融"><a href="#58金融" class="headerlink" title="58金融"></a>58金融</h2><blockquote><p><a href="/images/58-interview.png">另一份</a></p></blockquote><ul><li>微服务<ul><li>谈谈你理解的微服务</li><li>服务的划分依据</li><li>一次dubbo的完整调用过程</li></ul></li><li>mysql<ul><li>千万级别的数据，数据库需要考虑什么</li><li>数据库分库分表需要注意什么</li><li>索引需要考虑什么</li><li>最左原则</li><li>说说B+树和B树</li><li>讲讲幻读和不可重复读</li><li>讲讲数据库的乐观锁和悲观锁</li></ul></li><li>redis<ul><li>redis持久化</li></ul></li><li>队列<ul><li>kafka为什么比mq快</li></ul></li><li>zookeeper<ul><li>分布式锁</li><li>zookeeper选举策略，双数节点可以选举成功吗</li></ul></li><li>HashMap<ul><li>HashMap结构，为什么是数量是8转为红黑树</li><li>说说红黑树</li><li>怎么保证HashMap线程安全</li></ul></li><li>线程<ul><li>线程生命周期，什么时候发生线程状态变为死亡</li><li>讲讲CAS和AQS</li><li>ThreadLocal结构，与线程池一起使用会有什么问题吗？</li></ul></li><li>jvm<ul><li>讲讲你熟悉的GC收集器，特点，你们用的哪个</li><li>jvm调优怎么做</li></ul></li><li>排序<ul><li>快排</li></ul></li></ul><h2 id="瓜子"><a href="#瓜子" class="headerlink" title="瓜子"></a>瓜子</h2><h4 id="第一轮"><a href="#第一轮" class="headerlink" title="第一轮"></a>第一轮</h4><ul><li>coding:<ul><li>文件夹后续遍历: 先打印文件然后追层向上打印</li><li>无序数组，取出top N的N个元素</li></ul></li><li>ConcurrentHashMap 在JDK8的优化</li><li>jvm内存结构</li></ul><h4 id="第二轮"><a href="#第二轮" class="headerlink" title="第二轮"></a>第二轮</h4><ul><li>消息中间件的作用</li><li>并发<ul><li>为什么产生锁</li><li>threadlocal源码</li></ul></li><li>数据库<ul><li>mysql 索引</li><li>redis 雪崩　击穿</li></ul></li><li>jvm<ul><li>内存划分</li><li>新建对象放在哪里</li><li>G1收集器</li><li>增加吞吐量需要怎么设置参数</li></ul></li><li>优化分析<ul><li>接口变慢可能是什么原因？怎么优化?</li><li>dubbo的限流</li></ul></li><li>分布式<ul><li>接口幂等的实现方式</li><li>分布式锁</li></ul></li></ul><h2 id="洋钱罐"><a href="#洋钱罐" class="headerlink" title="洋钱罐"></a>洋钱罐</h2><ul><li>简单的sql手写(join)</li><li>mysql事务隔离级别</li><li>redis怎么用的<h4 id="算法手写"><a href="#算法手写" class="headerlink" title="算法手写"></a>算法手写</h4>二叉树根节点到叶子的数据和的最大值(广度优先,没一级存当前与上面的和，叶子节点就是总和)</li></ul><h2 id="vipkid"><a href="#vipkid" class="headerlink" title="vipkid"></a>vipkid</h2><ul><li>项目遇到的难点</li><li>redis cluster写热点key问题</li><li>一个线程池，3个线程执行完成就继续执行下去，写代码(CountdownLatch)</li><li>算法手写<ul><li>字符串反转</li><li>和为n的连续正整数序列</li><li>单链表反转</li></ul></li><li>等等</li></ul><h2 id="转转"><a href="#转转" class="headerlink" title="转转"></a>转转</h2><p>zk分布式锁的临时节点如何释放的<br>select for update是什么锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select from where id = &apos;&apos;</span><br><span class="line">select from where name = &apos;&apos;</span><br></pre></td></tr></table></figure><p>行锁还是表锁？<br>触发不到索引的查询有哪些<br>水平分表,同时满足订单id,卖家id和卖家id分别查询<br>dubbo为什么用代理(方法的多态,消费组)<br>线程池参数<br>算法</p><ul><li>用map,  list, array, stack 实现LRU cache</li><li>反转单链表</li><li>不用Java Api实现字符串转整型</li><li>足够量大的动物的动物园有一种动物是一只的，其他种类是两只的，找出这种动物</li></ul><h2 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h2><ul><li>spring　aop ioc, 动态代理中jdk和clib的区别  </li><li>redis线程模型为什么快(NIO)  </li><li>redis分布式锁,多线程，某个线程阻塞超时，重新执行时锁已被其他获取，自己删除别人的这个锁(怎么解决标记锁所属线程，保证原子性)</li><li>dubbo的执行过程, 代理监听和执行这中间做了什么</li><li>HashMap为什么线程不安全(rehash时链表成环)</li><li>ConcurrentHashMap怎么做到的分段锁，怎么得到的当前的大小</li><li>线程池参数</li><li>AQS怎么做的线程放入队列，释放锁唤醒队列线程(源码细节)</li><li>CAS</li><li>mysql事务隔离级别</li><li>索引结构，　B+树数据全部存在叶子节点的好处(B树也可以把数据连起来啊)</li><li>回表,覆盖索引</li></ul><h2 id="新浪金融"><a href="#新浪金融" class="headerlink" title="新浪金融"></a>新浪金融</h2><p>算法</p><ul><li>leetcode 821题</li><li>斐波纳契数列(非递归实现)</li><li>二分查找</li><li>ArrayList删除指定元素(考虑越界问题)</li><li>懒加载单例</li></ul><p>java内存模型，垃圾回收策略，jvm调优(堆为什么也不能设置很大？)<br>Spring AOP, IOC原理？ JDK动态代理和cglib的区别？ Spring事务嵌套？<br>Mybatis如何防止SQL注入的<br>dubbo生产者和消费者与zk的流程，负载均衡是在哪配置的？<br>设计模式有哪些<br>事务的特性ACID<br>HashMap的存储结构，put的操作过程<br>sleep和wait的区别<br>synchronized用在不同方法的情况<br>分布式锁<br>讲讲你熟悉的框架，技术    </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络基础知识</title>
      <link href="/network-base/"/>
      <url>/network-base/</url>
      
        <content type="html"><![CDATA[<p>网络基础知识整理<br><a id="more"></a></p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><ul><li><strong>物理层(网卡)</strong>: 比特流; 二级制-&gt;电流强弱-&gt;二进制 (数模, 模数 转换)</li><li><strong>数据链路层(交换机)</strong>: 帧; 格式化数据，错误检测和纠正</li><li><strong>网络层(路由器)</strong>: 分组数据报; 网络地址转换为物理地址，并决定如何发送到接收方，路径；IP协议</li><li><strong>传输层</strong>: 分段； 拆分为多个数据包segment, 决定传输速率，顺序；TCP协议</li><li><strong>会话层</strong>: 管理应用程序自动发包，寻址。不同机器上</li><li><strong>表示层</strong>: 不同系统通信语法解决，格式化</li><li><strong>应用层</strong>: 规定消息头格式，消息体。解读信息</li></ul><p>TCP/IP(OSI的实现)</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>面向连接、可靠的、基于字节流的传输层通信协议</li><li>将应用层数据流分割成报文段并发送给目标节点TCP层</li><li>数据包有序号，发ACK确认</li><li>使用校验和检验数据在传输过程</li></ul><p>TCP 标志</p><ul><li>URG: 紧急指针标志</li><li>ACK: 确认序号标志</li><li>PSH: push标志</li><li>RST: 重置连接标志</li><li>SYN: 同步序号，用于建立连接过程</li><li>FIN: finish标志, 用于释放连接</li></ul><h2 id="TCP三个握手"><a href="#TCP三个握手" class="headerlink" title="TCP三个握手"></a>TCP三个握手</h2><ul><li>①建立连接时，客户端发送SYN包到服务器，并进去 <code>SYN_SEND</code> 状态，等待服务器确认。 <code>SYN=1, seq=x</code>。</li><li>②服务器收到SYN包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)， 此时服务器进入<code>SYN_RECV</code> 状态； <code>SYN=1, ACK=1, seq=y, ack=x+1</code>。</li><li>③客户端收到服务器 SYN+ACK 包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入连接状态；<code>ACK=1，seq=x+1, ack=y+1</code>。</li></ul><p>为什么是三次握手?<br>为初始化Sequence Number的初始值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>apollo实时更新问题</title>
      <link href="/apollo-refresh/"/>
      <url>/apollo-refresh/</url>
      
        <content type="html"><![CDATA[<h3 id="大概介绍"><a href="#大概介绍" class="headerlink" title="大概介绍"></a>大概介绍</h3><p>分布式配置, 统一管理不同环境，不同集群的配置。  </p><ul><li>配置修改时服务端实时推送到客户端，客户端数据存在内存(不用自己管理),并缓存在本地文件中；同时客户端一段时间(默认5分钟)也会主动去服务端拉数据，防止推送失败</li><li>分为configService、adminService、portalService</li><li><a href="https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">部署文档</a>、<a href="https://github.com/ctripcorp/apollo/wiki/Java客户端使用指南" target="_blank" rel="noopener">使用文档</a></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>配置的更新推送，更新的是本地内存, 我们希望接收到更新到spring context中去。甚至重新初始化bean，重新建立数据库连接等，做到通过apollo集中管理配置更新，无需程序重新启动的完成配置更新。<br><a id="more"></a></p><h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h3><p>① apollo提供了changeListner监听事件，可以在监听到更新后，对已有的Properties的属性完成更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConfigService.getAppConfig().addChangeListener(changeEvent -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;Changes for namespace &quot; + changeEvent.getNamespace());</span><br><span class="line">            for (String key : changeEvent.changedKeys()) &#123;</span><br><span class="line">                ConfigChange change = changeEvent.getChange(key);</span><br><span class="line">                System.out.println(String.format(&quot;Found change - key: %s, oldValue: %s, newValue: %s, changeType: %s&quot;, change.getPropertyName(), change.getOldValue(), change.getNewValue(), change.getChangeType()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>② 将对于的更改更新到spring中去，Spring cloud 提供了<code>RefreshScope</code>，示例演示<code>@ConfigurationProperties</code>配置的bean更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Testconfig &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;test&quot;)</span><br><span class="line">    public Testconfig testconfig() &#123;</span><br><span class="line">        return new Testconfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SpringBootApolloRefreshConfig springBootApolloRefreshConfig() &#123;</span><br><span class="line">        return new SpringBootApolloRefreshConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringBootApolloRefreshConfig &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(SpringBootApolloRefreshConfig.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Testconfig testconfig;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RefreshScope refreshScope;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ContextRefresher contextRefresher;</span><br><span class="line"></span><br><span class="line">    public SpringBootApolloRefreshConfig() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApolloConfigChangeListener(value = ConfigConsts.NAMESPACE_APPLICATION)</span><br><span class="line">    public void onChange(ConfigChangeEvent configChangeEvent) &#123;</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;before refresh: &#123;&#125;&quot;, testconfig.toString());</span><br><span class="line">        refreshScope.refreshAll();</span><br><span class="line">        contextRefresher.refresh();</span><br><span class="line">        logger.info(&quot;after refresh: &#123;&#125;&quot;, testconfig.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 完成如dataSource, 更新配置后，完成新建数据库连接，新的请求转到新的连接，旧连接逐步销毁 // TODO<br><a href="https://github.com/ctripcorp/apollo/issues/773" target="_blank" rel="noopener">参考这个讨论</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> apollo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件面试常见问题</title>
      <link href="/message-middleware/"/>
      <url>/message-middleware/</url>
      
        <content type="html"><![CDATA[<p>消息中间件面试常见问题, <a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">整理自github</a><br><a id="more"></a></p><h3 id="一、为什么用消息队列"><a href="#一、为什么用消息队列" class="headerlink" title="一、为什么用消息队列?"></a>一、为什么用消息队列?</h3><ul><li><strong>解耦</strong>(发布订阅模型)、<strong>异步</strong>(速度快)、<strong>削峰</strong>(从mq拉的速度控制一下)</li><li><strong>可用性降低</strong>(mq挂)、<strong>系统复杂度高</strong>(消息重复、消息丢失、消息顺序)、<strong>一致性问题</strong>(多个系统消费可能存在失败的)</li><li>结合项目体现</li></ul><h3 id="二、ActiveMQ、RabbitMQ、RocketMQ、Kafka优缺点，如何选型"><a href="#二、ActiveMQ、RabbitMQ、RocketMQ、Kafka优缺点，如何选型" class="headerlink" title="二、ActiveMQ、RabbitMQ、RocketMQ、Kafka优缺点，如何选型"></a>二、ActiveMQ、RabbitMQ、RocketMQ、Kafka优缺点，如何选型</h3><ul><li>ActiveMQ社区不活跃，没经过大规模吞吐场景验证，不推荐</li><li>RabbitMQ，erlang开发，阻止了大多人深入底层，中小公司推荐；社区活跃不会黄</li><li>RocketMQ，适合大公司，自己有实力</li><li>Kafka，大数据实时计算，日志采集的业界标准</li></ul><h3 id="三、如何保证消息队列的高可用？"><a href="#三、如何保证消息队列的高可用？" class="headerlink" title="三、如何保证消息队列的高可用？"></a>三、如何保证消息队列的高可用？</h3><ul><li>RabbitMQ, 基于主从<ul><li>普通集群模式 (无高可用，数据只存在一台机器，消费时需要mq实例去实际存数据的mq拉取数据,一台那个实例机器挂了系统就挂了)</li><li>镜像集群模式 (数据会在多个mq实例之间同步可实现高可用；但是queue的数量无法扩展，如果queue的数量大到机器无法承受，再加机器也是没用的)</li></ul></li><li>Kafka,<ul><li>架构认识：由多个Broker组成，创建一个topic可以划分为多个partition，每个partition存在不同的broker里。就是说每个topic的数据存在不同的机器中，3个partition就是3个机器中</li><li>0.8以前，如果一个实例挂，就相当于topic丢了一部分数据。之后加入了replica副本，partition会存在副本；自动选举leader和follower；</li><li>读写全部从leader节点；写数据的时候，leader存本地磁盘，follower主动去leader拉，全部follower拉完会发ack给leader，再返回给生产者；读数据时，只有所有follower都返回ack同步成功的才会被消费</li></ul></li></ul><h3 id="四、-消息队列的重复消费、幂等性？"><a href="#四、-消息队列的重复消费、幂等性？" class="headerlink" title="四、 消息队列的重复消费、幂等性？"></a>四、 消息队列的重复消费、幂等性？</h3><ul><li>都可能出现重复消费，这是开发来保证的不是MQ</li><li>对于kafka，有一个offset概念，代表消息的序号，每隔一段时间消费者会把消费过的offset提交，表示已经消费过了，但异常情况来不及提交，会重复消费，所以需要我们开发自己来保证幂等性</li></ul><h3 id="五、如何保证可靠性、消息丢失？"><a href="#五、如何保证可靠性、消息丢失？" class="headerlink" title="五、如何保证可靠性、消息丢失？"></a>五、如何保证可靠性、消息丢失？</h3><ul><li>RabbitMQ<ul><li>生产者丢失数据: <code>confirm</code>模式,生产者设置开启confirm模式后，每次写消息会被分配一个全局唯一id，如果写入成功会返回ack，失败则回调`nack接口告诉你接收失败可以重试；过程是异步的</li><li>MQ丢失数据: 数据持久化到本地，启动后数据读取之前存储的数据，极少数存在还未持久化MQ就已经挂了; 也可以与生产者ack关联，为持久化的消息重新发送</li><li>消费者丢失数据: 刚消费到还没处理，进程就挂了；可以用ack，每次消费完成发送ack，否则MQ认为没有被消费</li></ul></li><li>Kafka<ul><li>消费端丢失: 消费了未处理，就自动提交了offset；此情况可以关闭自动提交，处理完成后才手动提交</li><li>Kafka丢失: 某个Broker中leader挂了，还未来得及同步partition，进行了选举；所以配置一些参数:<ul><li><strong>保证每个partition至少有两个副本</strong>: topic的 <code>replication.factor</code>  大于1</li><li><strong>leader感知至少有一个follower存在</strong>: kafka设置<code>min.insync.replicas</code>大于1</li><li><strong>写入所有的replica,才认为是成功</strong>: producer设置 <code>acks=all</code> </li><li><strong>一旦写入失败无限重试</strong>: producer设置 <code>retries=MAX</code> </li></ul></li><li>生产者不会丢失，因为所有到接收到才算成功</li></ul></li></ul><h3 id="六、消息消费的顺序性"><a href="#六、消息消费的顺序性" class="headerlink" title="六、消息消费的顺序性?"></a>六、消息消费的顺序性?</h3><ul><li>保证一个queue或topic，或同一类的消息由同一个消费者消费</li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-order-of-messages.md" target="_blank" rel="noopener">参见</a></li></ul><h3 id="七、延时过期失效、队列满了、消息积压几个小时，怎么解决？"><a href="#七、延时过期失效、队列满了、消息积压几个小时，怎么解决？" class="headerlink" title="七、延时过期失效、队列满了、消息积压几个小时，怎么解决？"></a>七、延时过期失效、队列满了、消息积压几个小时，怎么解决？</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mq-time-delay-and-expired-failure.md" target="_blank" rel="noopener">这里</a></p><ul><li>就是消费端出现了问题</li></ul><h3 id="八、设计消息队列的思路"><a href="#八、设计消息队列的思路" class="headerlink" title="八、设计消息队列的思路"></a>八、设计消息队列的思路</h3><ul><li>可伸缩，动态扩容： 参考kafka，每个机器存一部分数据，如果资源不够了，给topic增加partition，然后做数据迁移，增加机器，就可以存放更多数据</li><li>数据持久化： 顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li><li>可用性： 参考之前的，多副本，leader&amp;follower-&gt;broker, 挂了就重新选举</li><li>数据零丢失: 之前的方案</li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mq-design.md" target="_blank" rel="noopener">这里</a> </li></ul><blockquote><p><a href="https://www.jianshu.com/p/824066d70da8" target="_blank" rel="noopener">RocketMQ 实战之快速入门</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过nginx自建文件共享服务，用手机播放电脑的视频</title>
      <link href="/nginx-file-share/"/>
      <url>/nginx-file-share/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>最近想把一些学习视频共享给小伙伴，结果发现网盘生成链接很容易失效，下载限速严重；加上手机内存有限观看下载好的视频很不方便；所以觉得搞一下本地文件服务器，来分享文件；同时手机也可以连接在线观看视频，因为是内网，速度拉满<br><a id="more"></a></p></blockquote><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>mac(windows有乱码问题)<br>安装好nginx</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>nginx.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        charset      utf-8,gbk; # windows 服务器下设置后，依然乱码，暂时无解</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root         /Users/yuan/sp; #共享目录，Windows目录这样写 d://www//</span><br><span class="line">            autoindex on; ##显示索引</span><br><span class="line">            autoindex_exact_size on; ##显示大小</span><br><span class="line">            autoindex_localtime on;   ##显示时间</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注:<br>查看默认nginx配置文件位置执行: <code>nginx -h</code>, 如下可知，-c对应的/usr/local/etc/nginx/nginx.conf，即是当前默认配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yuandeMacBook-Pro-2:nginx yuan$ nginx -h</span><br><span class="line">nginx version: nginx/1.15.3</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this help</span><br><span class="line">  -v            : show version and exit</span><br><span class="line">  -V            : show version and configure options then exit</span><br><span class="line">  -t            : test configuration and exit</span><br><span class="line">  -T            : test configuration, dump it and exit</span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : set prefix path (default: /usr/local/Cellar/nginx/1.15.3/)</span><br><span class="line">  -c filename   : set configuration file (default: /usr/local/etc/nginx/nginx.conf)</span><br><span class="line">  -g directives : set global directives out of configuration file</span><br></pre></td></tr></table></figure></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>启动nginx<br>访问<code>http://127.0.0.1</code>即可，手机访问更换为电脑ip</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>nginx命令及教程推荐参考 <a href="https://github.com/dunwu/nginx-tutorial" target="_blank" rel="noopener">Nginx极简教程</a></p><p><a href="https://www.tiezi.xyz/archives/647.html" target="_blank" rel="noopener">自建视频网站</a></p>]]></content>
      
      
      <categories>
          
          <category> 好玩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 站内文章引用</title>
      <link href="/Hexo-internal-link/"/>
      <url>/Hexo-internal-link/</url>
      
        <content type="html"><![CDATA[<p>格式如下, 链接文字可省略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link 文件名 链接文字 %&#125;</span><br></pre></td></tr></table></figure></p><p>如: 链接到文件: hello.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link hello %&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link hello 这是指向hello的链接 %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal源码分析</title>
      <link href="/threadlocal/"/>
      <url>/threadlocal/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以前接触过ThreadlLocal，不过只是一点点并且没有及时记录下来，最近看了一些博客并结合源码，了解了一番，很有必要记录一下。<br>欢迎指正~<br><a id="more"></a></p><h3 id="一、简单介绍"><a href="#一、简单介绍" class="headerlink" title="一、简单介绍"></a>一、简单介绍</h3><p>ThreadLocal可以存储当前线程下的数据，并保持各线程的数据互不干扰。方便使用，并减少传输。<br>使用起来类似HashMap的key，value形式，set和get，不过同一个ThreadLocal对象只能存储一个值</p><h3 id="二、一般使用"><a href="#二、一般使用" class="headerlink" title="二、一般使用"></a>二、一般使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般以private static方式定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        threadLocal2 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        threadLocal.set(<span class="string">"abc"</span>);</span><br><span class="line">        threadLocal2.set(<span class="string">"bcd"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">        System.out.println(threadLocal2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>整体结构: Thread下存ThreadLocalMap-&gt;Entry数组-&gt;数组的下标通过key(当前ThreadLocal对象)的hash函数确定，Entry对象存在key和value属性</p></blockquote><h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><blockquote><p>来自: JDK1.8</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap.set()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">              e != <span class="keyword">null</span>;</span><br><span class="line">              e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">          ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">              e.value = value;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">              replaceStaleEntry(key, value, i);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">      <span class="keyword">int</span> sz = ++size;</span><br><span class="line">      <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">          rehash();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过上面代码发现，set的过程是:</p><ol><li>首先获取当前线程Thread对象的ThreadLocalMap引用  <code>getMap(t)</code> 的 <code>t.threadLocals</code></li><li>然后对ThreadLocalMap引用进行 <code>map.set()</code></li><li>ThreadLocal对象作为key将值存到ThreadLocalMap下的Entry数组中(类似HashMap，它是通过hash与数组长度减1与，离散的存到数组的不同索引位置，不同的是，由于不是链表的结构，需要判断即将插入的位置和当前元素的关系，来调整位置)</li></ol><p>注:ThreadLocalMap是ThreadLocal的内部类，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">      <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">      Object value;</span><br><span class="line"></span><br><span class="line">      Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">          <span class="keyword">super</span>(k);</span><br><span class="line">          value = v;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>从上面又可以看出，<strong>ThreadLocalMap是在ThreadLocal中使用内部类来编写的，但对象的引用是在Thread中！</strong></li><li>于是可以总结出：<strong>Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象</strong></li></ul><p>下面再来看get()就不难了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、内存泄露"><a href="#四、内存泄露" class="headerlink" title="四、内存泄露"></a>四、内存泄露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Entry的key保存在外部的 <code>WeakReference</code>，弱引用，ThreadLocal在没有外部强引用时，可以被GC回收</li><li>但如果线程一直在运行，这个Entry的value一直不能被回收，强引用，会发生内存泄露;Entry是key的弱引用，不是实例对象value的弱引用，无法避免内存泄露</li><li>为了尽量避免泄露，在不需要的时候，执行 <code>remove()</code> 方法</li></ol><blockquote><p>引用:<br><a href="https://www.jianshu.com/p/282a00c9c583" target="_blank" rel="noopener">Java WeakReference的理解与使用</a><br><a href="https://juejin.im/post/5b82c02df265da436152f5ad" target="_blank" rel="noopener">理解Java的强引用、软引用、弱引用和虚引用</a></p></blockquote><p><strong>remove做了什么呢?</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Remove the entry for key.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">              e.clear();</span><br><span class="line">              expungeStaleEntry(i);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reference.clear()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>clear()</code> 将key置null, 然后 <code>expungeStaleEntry(i)</code> 将Entry数组重新组合，遍历数组，key或value为空的对象置空</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><ol><li>存储当前线程可访问的数据，减少数据传输 <code>private static ThreadLocal&lt;T&gt; local</code></li><li>因为存储的值在ThreadLocalMap中，与每个线程绑定，所以各个线程间的访问互不影响</li><li>数据通过它的内部类ThreadLocalMap，存储在<code>ThreadLocalMap.Entry</code>中，最终是存储在每个线程Thread中的ThreadLocalMap引用</li><li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</li><li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li><li>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。</li></ol><p><strong>ThreadLocal设计的目的就是为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8笔记</title>
      <link href="/Java8-note/"/>
      <url>/Java8-note/</url>
      
        <content type="html"><![CDATA[<p>主要是Optional和Stream的基本用法<br><a id="more"></a></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><h5 id="逐层取值"><a href="#逐层取值" class="headerlink" title="逐层取值"></a>逐层取值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String version = <span class="string">"UNKNOWN"</span>;</span><br><span class="line"><span class="keyword">if</span>(computer != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Soundcard soundcard = computer.getSoundcard();</span><br><span class="line">        <span class="keyword">if</span>(soundcard != <span class="keyword">null</span>)&#123;</span><br><span class="line">             USB usb = soundcard.getUSB();</span><br><span class="line">             <span class="keyword">if</span>(usb != <span class="keyword">null</span>)&#123;</span><br><span class="line">                 version = usb.getVersion();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>改进: flatMap返回Optional对象, map提取属性值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = computer.flatMap(Computer::getSoundcard)</span><br><span class="line">                          .flatMap(Soundcard::getUSB)</span><br><span class="line">                          .map(USB::getVersion)</span><br><span class="line">                          .orElse(<span class="string">"UNKNOWN"</span>);</span><br></pre></td></tr></table></figure></p><h5 id="值处理"><a href="#值处理" class="headerlink" title="值处理"></a>值处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Soundcard&gt; soundcard = ...;</span><br><span class="line">soundcard.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(soundcard.isPresent())&#123;</span><br><span class="line">  System.out.println(soundcard.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Soundcard soundcard = maybeSoundcard != <span class="keyword">null</span> ? maybeSoundcard : <span class="keyword">new</span> Soundcard(<span class="string">"basic_sound_card"</span>);</span><br></pre></td></tr></table></figure><p>改进:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Soundcard soundcard = maybeSoundcard.orElse(<span class="keyword">new</span> Soundcard(<span class="string">"defaut"</span>));</span><br></pre></td></tr></table></figure></p><p>抛异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Soundcard soundcard = </span><br><span class="line">  maybeSoundCard.orElseThrow(IllegalStateException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></p><h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USB usb = ...;</span><br><span class="line"><span class="keyword">if</span>(usb != <span class="keyword">null</span> &amp;&amp; <span class="string">"3.0"</span>.equals(usb.getVersion()))&#123;</span><br><span class="line">  System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;USB&gt; maybeUSB = ...;</span><br><span class="line">maybeUSB.filter(usb -&gt; <span class="string">"3.0"</span>.equals(usb.getVersion())</span><br><span class="line">                    .ifPresent(() -&gt; System.out.println(<span class="string">"ok"</span>));</span><br></pre></td></tr></table></figure></p><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//get list of unique squares</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">//get count of empty string</span></span><br><span class="line"><span class="keyword">int</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="Parallel-Processing"><a href="#Parallel-Processing" class="headerlink" title="Parallel Processing"></a>Parallel Processing</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//get count of empty string</span></span><br><span class="line"><span class="keyword">long</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h5 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Filtered List: "</span> + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure><h5 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Highest number in List : "</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">"Lowest number in List : "</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">"Sum of all numbers : "</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">"Average of all numbers : "</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis五种数据类型</title>
      <link href="/Redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/Redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Redis五种数据类型的差异，适用场景等<br><a id="more"></a></p><p>不同数据结构的差异在于value的结构不一样</p><table><thead><tr><th>类型</th><th>对于Java</th><th>结构</th><th>应用</th></tr></thead><tbody><tr><td>string(字符串)</td><td>ArrayList</td><td>动态字符串提前扩容</td><td>存储序列化的对象</td></tr><tr><td>list(列表)</td><td>LinkedList</td><td>链表</td><td>可做队列、栈；保存最新的10个用户，进来一个就删除一个，保持最新用户</td></tr><tr><td>hash(字段)</td><td>HashMap</td><td></td><td>可以分别的存用户的信息</td></tr><tr><td>set(集合)</td><td>HashSet</td><td>value为null的HashMap</td><td>存中奖用户id，因为不可重复的特点</td></tr><tr><td>zset(有序集合)</td><td>SortedSet和HashMap的结合</td><td>value有权重值的set</td><td>可以value为用户id，score为分数，按分数对用户排序操作(zrange <name> 0 -1)</name></td></tr></tbody></table><h4 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string(字符串)"></a>string(字符串)</h4><ul><li>相当于Java中的ArrayList</li><li>redis中的字符串是动态字符串，是可以修改的字符串</li><li>动态分配内存<ul><li>字符串长度小于１MB时，扩容是加倍现有空间；</li><li>字符串大于１MB时，每次增加１MB;</li><li>字符串最大长度是512MB</li></ul></li><li>incr最大值是Long.Max </li><li>保存完整序列化对象<h4 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h4></li><li>Java中的LinkedList</li><li>可做队列: 右push + 左pop</li><li>可做栈: 右push  + 右pop</li><li>zipList: 数量较少时，连续的地址空间存储，节约头尾指针的内存空间</li><li>应用: 保存最新的10个用户，进来一个新的就删除一个旧的；得到最新10个用户<h4 id="hash-字典"><a href="#hash-字典" class="headerlink" title="hash(字典)"></a>hash(字典)</h4></li><li>Java中的HashMap</li><li>单独存储用户信息的每个字段<h4 id="set-集合"><a href="#set-集合" class="headerlink" title="set(集合)"></a>set(集合)</h4></li><li>中奖用户id，不可重复<br>Java中的HashSet<h4 id="zset-有序列表"><a href="#zset-有序列表" class="headerlink" title="zset(有序列表)"></a>zset(有序列表)</h4></li><li>value带有权重的set</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java面试</title>
      <link href="/Java-interview/"/>
      <url>/Java-interview/</url>
      
        <content type="html"><![CDATA[<p>面试中高级的一些准备提纲, <code>持续更新</code><br><a id="more"></a></p><blockquote><p><a href="http://nivelle.me/javaInterview/" target="_blank" rel="noopener">同学整理</a><br><a href="/interview-experience-2019/" title="2019面经">2019面经</a></p></blockquote><p><strong>整体参考</strong>:</p><ul><li><a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">高并发、分布式等，适合面试</a></li><li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">基础知识+算法题解、源码分析</a></li></ul><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><a href="/message-middleware/" title="消息中间件面试常见问题">消息中间件面试常见问题</a><p><a href="https://www.cnblogs.com/duanxz/p/4705164.html" target="_blank" rel="noopener">kafka为什么那么快</a></p><ul><li>生产者: 顺序写入、内存映射文件(同步或异步更新到磁盘)</li><li>消费者: 全部以文件方式发送到消费者<br>……</li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul><li>集合<ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap.md" target="_blank" rel="noopener">HashMap底层</a></li><li><a href="/Java-Collection/" title="Java集合总述">Java集合总述</a></li></ul></li><li>并发<ul><li><a href="/concurrent-note/" title="并发笔记">并发笔记</a></li></ul></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h4><ul><li><a href="/mysql-note/" title="mysql笔记">mysql笔记</a></li><li><a href="http://shanks.leanote.com/post/Mysql%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">索引详解</a></li></ul><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><blockquote><p><a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">github参考</a></p></blockquote><ul><li><a href="/redis-note/" title="redis笔记">redis笔记</a></li></ul><h2 id="Jvm"><a href="#Jvm" class="headerlink" title="Jvm"></a>Jvm</h2><a href="/JVM/" title="JVM">JVM</a><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h5 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h5><ul><li>与springcloud的区别-服务调用方式和关注点不同<ul><li>dubbo服务间调用采用RPC，长连接，性能会更好</li><li>支持多种序列化协议</li><li>不支持跨语言，自己再包装一层REST服务，相对更麻烦；服务提供和消费者强依赖</li><li>分布式配置、服务追踪等，需要借助其他框架，风险大</li><li>而对于springcloud，社区很活跃，提供了整套的微服务解决方案，部署快，支持REST，跨语言，提供了docker支持</li><li>选择的关注点：是否存在异构系统的集成问题；功能特性是否满足；http协议的通信是否会成为瓶颈点；springcloud也不是必须http+json也可配置；dubbo需要内部有一个维护的团队</li></ul></li><li><p>灰度<br>当一个接口出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互不调用，实现灰度发布,步骤如下:</p><ol><li>接口旧的实现定义version=”1.0.0”，接口新的实现version=”2.0.0”</li><li>Consumer端定义version=”*”</li></ol><p>这样定义Provider和Consumer后，新旧接口实现各承担<code>50%</code>的流量；<br>利用dubbo该特性，还能完成不兼容版本迁移：<br>在低压力时间段，先升级一半Provider为新版本；</p><ol><li>再将所有消费者升级为新版本；</li><li>然后将剩下的一半提供者升级为新版本。</li></ol></li><li>限流、降级(return null)</li><li><a href="http://dubbo.apache.org/zh-cn/blog/sentinel-introduction-for-dubbo.html" target="_blank" rel="noopener">dubbo sentinel</a></li><li><a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html" target="_blank" rel="noopener">dubbo spi</a></li><li>源码</li><li><a href="https://juejin.im/search?query=%E8%82%A5%E6%9C%9D&amp;type=all" target="_blank" rel="noopener">掘金-肥朝</a></li></ul><h5 id="service-mesh-是什么"><a href="#service-mesh-是什么" class="headerlink" title="service mesh 是什么"></a>service mesh 是什么</h5><h5 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h5><ul><li><a href="/spring-ioc/" title="spring ioc aop">spring ioc aop</a></li><li><a href="https://blog.csdn.net/qq_38182963/article/details/78795058" target="_blank" rel="noopener">spring扩展点</a></li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul><li>分布式事务</li><li>分布式锁<ul><li>redis<br><code>SET resource_name my_random_value NX PX 30000</code><br>NX：表示只有 key 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 nil）;<br>PX 30000：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。<br>优化: RedLock 算法; 对于redis cluster，尝试在大多数节点上建立锁就算成功，删除的时候依次删除</li><li>zookeeper<br>尝试创建临时znode节点，创建成功就获取到了这个锁；那么其他机器再去尝试创建znode节点会失败，只能注册个监听器监听这个锁。释放锁就是删除这个znode，一旦释放就会通知客户端，然后一个等待的客户端可以再次重新加锁</li><li>redis需要不断尝试去获取锁，开销较大；zk获取不到锁时，注册个监听器即可</li></ul></li><li>zookeeper<ul><li>分布式协调<br>Ａ系统发出请求以后可以在zookeeper上<strong>对某个节点的值注册个监听器</strong>,一旦Ｂ系统处理完成就修改zookeeper那个节点的值，Ａ系统立马可以收到通知</li><li>分布式锁<br>创建znode节点，那么其他机器再去尝试创建znode节点会失败</li><li>元数据/配置信息管理</li><li>HＡ高可用<br>一个重要的进程一般会做准备两个，主进程挂了立马通过zookeeper感知到切换刀备用进程</li></ul></li><li>一致性hash</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>几大排序：描述和代码实现 <a href="https://github.com/ZhongFuCheng3y/3y/blob/master/src/sort.md" target="_blank" rel="noopener">参考</a></li><li><a href="https://juejin.im/post/5b55660ee51d4519202e2003" target="_blank" rel="noopener">快排实现</a>: 分治</li><li><a href="https://www.jianshu.com/p/9e855ba2b079" target="_blank" rel="noopener">排序稳定性分析</a></li><li><a href="https://juejin.im/post/5b15ff73e51d4506b113d956" target="_blank" rel="noopener">二分查找</a></li><li><a href="https://www.jianshu.com/p/0755888b946b" target="_blank" rel="noopener">斐波那契</a></li><li><a href="https://www.jianshu.com/p/86a1fd2d7406" target="_blank" rel="noopener">B树、B+树与红黑树</a></li><li><a href="https://dyygusi.iteye.com/blog/2162617" target="_blank" rel="noopener">深度和广度优先</a></li><li><a href="https://www.jianshu.com/p/138ff21d9ede" target="_blank" rel="noopener">最长回文子串</a></li><li><a href="https://blog.csdn.net/xjy9266/article/details/75371179" target="_blank" rel="noopener">懒加载单例</a></li><li>手写工厂模式</li><li>手写生产者消费者</li><li>动态代理</li></ul><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><ul><li><a href="https://doocs.gitee.io/coding-interview/#/docs/coding-interview" target="_blank" rel="noopener">剑指offer</a></li><li><a href="https://github.com/doocs/leetcode" target="_blank" rel="noopener">leetcode</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/CyC2018/" target="_blank" rel="noopener">看看知识和岗位</a></li><li><a href="https://github.com/CyC2018/Markdown-Resume" target="_blank" rel="noopener">简历模板</a></li><li><a href="https://github.com/CyC2018/Backend-Interview-Guide/blob/master/doc/%E5%86%99%E5%A5%BD%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86.md" target="_blank" rel="noopener">写简历</a></li><li><a href="https://github.com/CyC2018/Backend-Interview-Guide/blob/master/doc/%E6%89%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E8%BF%87%E7%A8%8B.md" target="_blank" rel="noopener">扫码登录</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/JVM/"/>
      <url>/JVM/</url>
      
        <content type="html"><![CDATA[<p>Java内存模型，垃圾收集器、类加载<br><a id="more"></a></p><p>jdk包含jre，jre包含jvm</p><h2 id="初试-分析解决"><a href="#初试-分析解决" class="headerlink" title="初试,分析解决"></a>初试,分析解决</h2><p>查看堆存储快照<br>VM arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure></p><p>设置堆内存大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20m -Xmx20m</span><br></pre></td></tr></table></figure></p><p>分析工具：eclipse memory analyzer</p><h2 id="JVM监控工具"><a href="#JVM监控工具" class="headerlink" title="JVM监控工具"></a>JVM监控工具</h2><p>jdk/bin/jconsole  直接运行<br>堆内存，分为新生代和老年代。垃圾回收会对新生代进行回收。新生代分为，Eden和两个Survivor。<br>垃圾回收会回收一部分Eden，存活的进入到Survivor生存区。存活久的进入到老年代。</p><h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>第一款商用Java虚拟机</li><li>只能使用解释器方式执行java</li></ul><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul><li>编译器和解释器混合执行，两级即时编译器</li><li>只在Solaris平台发布，就被取代了</li></ul><h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><ul><li>称霸武林</li><li>非sun开发，后收购的</li></ul><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><ul><li>手机平台运行</li></ul><h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><ul><li>BEA公司</li><li>专注服务器端</li></ul><h3 id="J9"><a href="#J9" class="headerlink" title="J9"></a>J9</h3><p>-IBM</p><h3 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h3><h2 id="Java虚拟机内存结构"><a href="#Java虚拟机内存结构" class="headerlink" title="Java虚拟机内存结构"></a>Java虚拟机内存结构</h2><p>分为：  </p><p>线程独占区<br>生命周期随着线程的创建而创建，随着线程的结束而死亡；所以不用关心这部分的垃圾回收。</p><ul><li>程序计数器：当前线程执行字节码行号指示器。</li><li>虚拟机栈：一个个栈帧组成的，局部变量表、操作数栈、动态链接、方法出口信息；每个方法执行，创建一个栈帧，伴随方法的创建到结束，存储局部变量表等，方法执行完毕，出栈。</li><li>本地方法栈：与虚拟机栈类似，不过提供的是native方法运行。</li></ul><p>线程共享区</p><ul><li>堆：存储几乎所有的对象实例，虚拟机创建而创建。垃圾回收的主要区域。  </li><li>方法区：存储类信息，常量，静态变量。编译后的代码。</li></ul><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul><li>一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。  </li><li>处于线程独占区，线程私有  </li><li>此区域是Java虚拟机规范中，唯一没有规定任何OutOfMemoryError情况的区域。</li><li>生命周期随着线程的创建而创建，随着线程的结束而死亡。 </li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul><li>Java方法执行的动态内存模型</li><li>栈放的是对象的引用</li><li>栈帧：每个方法的执行，都创建一个栈帧，伴随方法的创建到执行完成，用于存储局部变量表，操作数栈，动态链接，方法出口。</li><li>当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。<br>当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。</li><li>栈内存溢出则，报错StackOverFlow（如递归）</li></ul><p>注意：人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。<br>这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。真正的Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul><li>虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机执行native方法服务。</li><li>本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。</li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>存储对象实例，(几乎所有的对象都存储在堆中)</li><li>虚拟机启动时创建</li><li>垃圾收集器管理的主要区域</li><li>老年代，新生代；新生代又被分为Eden、From Survivor、To Survivor。不同区域生命周期不同，根据区域垃圾回收。</li><li>-Xms  -Xmx</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</li><li>方法区和永久代</li><li>垃圾回收在方法区的行为</li><li>异常的定义</li><li>运行时常量池，字符串会放到常量池里，类似hashset的table，如 String a = “aa”. String 的intern是把对象搬到运行时常量。</li></ul><h3 id="直接内存-不属于虚拟机内存"><a href="#直接内存-不属于虚拟机内存" class="headerlink" title="直接内存(不属于虚拟机内存)"></a>直接内存(不属于虚拟机内存)</h3><ul><li>除Java虚拟机以外的内存，也有可能被Java使用。</li><li>NIO， 在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。</li><li>直接内存大小不受Java虚拟机控制，不过，内存不足时就会抛出OOM异常。</li></ul><h3 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h3><ul><li>Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。<br>两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。<br>只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。</li><li>Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。</li></ul><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>1、new 类名<br>2、根据new的参数在常量池中定义一个类的引用符号。<br>3、如果没有找到这个符号引用，说明类还没有被加载，进行类的加载，解析和初始化。<br>4、虚拟机为对象分配内存，（堆）<br>5、将分配的内存初始化为零值（不包括对象头）<br>6、调用对象的init方法。（代码块，构造方法）</p><h3 id="给对象分配内存"><a href="#给对象分配内存" class="headerlink" title="给对象分配内存"></a>给对象分配内存</h3><ul><li>指针碰撞(指针移动)，连续的空间。</li><li>空闲列表：一张表，记录空闲内存。在空闲的部分分配内存。</li><li>线程安全<ul><li>加锁</li><li>每个线程单独分配自己的区域，叫做本地线程分配缓冲</li></ul></li></ul><h3 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h3><ul><li>Header<ul><li>自身运行时数据(Mark Word)<ul><li>哈希值</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li>类型指针</li></ul></li><li>InstanceData</li><li>Padding</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>栈的对象引用指向堆的对象实例。</p><ul><li>使用句柄：指向堆中的句柄池，句柄池指向对象的地址</li><li>直接指针：直接指向对象的地址(hotspot)</li></ul><p>具体哪一种方式，跟虚拟机有关。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判定对象为垃圾"><a href="#如何判定对象为垃圾" class="headerlink" title="如何判定对象为垃圾"></a>如何判定对象为垃圾</h3><ul><li>引用计数法：在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数+1，当引用失效引用计数-1.引用计数为0时回收。</li><li>可达性分析:根节点(GC Roots)不能到达的回收。GC Roots包括：<ul><li>虚拟机栈</li><li>方法区的类属性所引用的对象</li><li>方法区中常量所引用的对象</li><li>本地方法栈中所引用的对象<h3 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h3><h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4>新生代通常复制算法，老年代标记-整理，标记清除。老年代对象一般较大不适合复制算法，浪费空间。标记-整理在可用对象多的情况下很适合。</li></ul></li><li>标记-清除算法<ul><li>效率问题</li><li>空间问题</li></ul></li><li><p>复制算法:(针对新生代)解决标记清除的效率问题；两块相同的内存，每次只用一块区域，回收时把不需要回收的部分复制到另一块内存，并连续排列，原来的内存区全部清空，下一次在这块区域继续划分，循环这种操作。</p><blockquote><p>内存浪费的解决方案。新生代分为Eden，From Survivor，To Survivor，比例是8：1：1。我们认为垃圾回收后剩余大约10%的有用对象。在Eden的对象垃圾收集以后剩余的放在Survivor，From与To之间是复制算法的关系。当Survivor内存不够时就需要一个内存担保，Tenured Gen。放到老年代。</p></blockquote></li><li><p>标记-整理算法:针对老年代，整理以后清除。</p></li><li>分代收集算法：根据垃圾需要收集的多少决定用复制还是标记-整理算法</li></ul><h4 id="常见回收器-Java虚拟机没有规范，下面的不同收集器适用不同的场景"><a href="#常见回收器-Java虚拟机没有规范，下面的不同收集器适用不同的场景" class="headerlink" title="常见回收器(Java虚拟机没有规范，下面的不同收集器适用不同的场景)"></a>常见回收器(Java虚拟机没有规范，下面的不同收集器适用不同的场景)</h4><ul><li>Serial(-XX:+UseSerialGC,新生代, 复制算法)<ul><li>最基本，发展最悠久的</li><li>单线程(多线程任务执行，垃圾收集时全部线程暂停等待单线程的收集，收集完继续多个线程的执行)</li><li>桌面应用</li></ul></li><li>ParNew(-XX:+UseParNewGC, 新生代, 复制算法)<ul><li>多线程</li></ul></li><li>Parallel Scavenge(-XX:+UserParellelGC)<ul><li>复制算法(新生代收集器)</li><li>多线程收集器</li><li>吞吐量:(执行用户代码的时间) / 总时间</li><li>达到可控制的吞吐量</li><li>-XX：MaxGCPauseMillis 垃圾收集器最大停顿时间</li><li>-XX:GCTimeRatio 吞吐量大小， 取值(0, 100)</li></ul></li><li>Serial Old(-XX:+UseSerialOldGC, 标记-整理)<ul><li>老年代收集器, Serial的老年代版本</li></ul></li><li>Parallel Old<ul><li>老年代</li></ul></li><li>CMS(Concurrent Mark Sweep)<ul><li>针对老年代</li><li>停顿时间很短</li></ul></li><li>G1(-XX:+UseG1GC, 复制+标记+整理)<ul><li>面向服务端</li><li>综合前面的优势</li><li>并行和并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li><li>标记整理</li></ul></li></ul><h3 id="何时回收"><a href="#何时回收" class="headerlink" title="何时回收"></a>何时回收</h3><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="1-优先分配到eden"><a href="#1-优先分配到eden" class="headerlink" title="1. 优先分配到eden"></a>1. 优先分配到eden</h3><p>打印垃圾收集信息： -verbose:gc -XX:+PrintGCDetails</p><h3 id="2-大对象直接分配到老年代"><a href="#2-大对象直接分配到老年代" class="headerlink" title="2. 大对象直接分配到老年代"></a>2. 大对象直接分配到老年代</h3><p>指定大对象的大小： -XX:PretenureSizeThreshold=8M<br>新生代通常是复制算法，新生代垃圾回收的频率很高，所以放在老年代更好。</p><h3 id="3-长期存活的对象分配到老年代-jdk7以后不严格"><a href="#3-长期存活的对象分配到老年代-jdk7以后不严格" class="headerlink" title="3. 长期存活的对象分配到老年代(jdk7以后不严格)"></a>3. 长期存活的对象分配到老年代(jdk7以后不严格)</h3><p>指定年龄多少算长期 -XX:MaxTenuringThreshold 15<br>年龄计数器，每次垃圾回收年龄+1</p><h3 id="4-空间分配担保"><a href="#4-空间分配担保" class="headerlink" title="4. 空间分配担保"></a>4. 空间分配担保</h3><p>内存不够时借用老年代内存<br>需要检查老年代是否有足够的空间容纳全部的新生代<br>开启空间分配担保  -XX:+HandlePromotionFailure<br>禁用空间分配担保  -XX:-HandlePromotionFailure</p><h3 id="5-动态对象的年龄判断"><a href="#5-动态对象的年龄判断" class="headerlink" title="5. 动态对象的年龄判断"></a>5. 动态对象的年龄判断</h3><h3 id="6-逃逸分析和栈上分配"><a href="#6-逃逸分析和栈上分配" class="headerlink" title="6. 逃逸分析和栈上分配"></a>6. 逃逸分析和栈上分配</h3><p>逃逸分析：分析对象的作用域。<br>栈上分配是java虚拟机提供的一种优化技术</p><p>只在方法体内部有效，不发生逃逸。反之。<br>为成员属性赋值，发生逃逸；<br>对象的作用域仅在当前方法有效，没有发生逃逸。<br>引用成员变量的值，发生逃逸。</p><p>没有发生逃逸的对象放在栈内存中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartionOnStack</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  User user;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    user=<span class="keyword">new</span> User();</span><br><span class="line">    user.id=<span class="number">1</span>;</span><br><span class="line">    user.name=<span class="string">"sixtrees"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为上面的代码中的User的作用域是整个Main Class，所以user对象是可以逃逸出函数体的。下面的代码展示的则是一个不能逃逸的代码段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartionOnStack</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.id=<span class="number">1</span>;</span><br><span class="line">    user.name=<span class="string">"sixtrees"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PartionOnStack pos=<span class="keyword">new</span> PartionOnStack();</span><br><span class="line">    pos.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="虚拟机工具"><a href="#虚拟机工具" class="headerlink" title="虚拟机工具"></a>虚拟机工具</h2><ul><li><p>Jps</p><ul><li>Java process status</li><li>控制台 打 “jps”. 显示Java进程id</li><li>jps -l 运行时主类全名或jar包名</li><li>jps -m 运行时主类接收的参数(在args中)</li><li>jps -v 接收的VM的参数</li><li>本地虚拟机唯一Id  lvmid local virtual machine id</li></ul></li><li><p>Jstat</p><ul><li>依赖jps， 需要知道进程的id才能使用</li><li>官网可查看文档</li><li>jstat -gcutil {id}  垃圾回收概要信息</li></ul></li><li><p>Jinfo  </p><ul><li>实时查看和调整虚拟机的各项参数</li><li>jinfo -flag UseSerialGC {id}  查看该进程是否使用SerialGC。是(+),否(-)</li></ul></li><li><p>Jmap  </p><ul><li>jmap -dump:format=b,file=/Users/yuan/a.bin {进程id}  转储快照</li><li>jmap -histo {id} 类和实例信息</li></ul></li><li><p>Jhat</p><ul><li>分析Jmap快照</li><li>jhat {文件路径}</li><li>启动http server</li></ul></li><li><p>Jstack</p><ul><li>线程快照</li><li>Jstack {id}</li></ul></li><li><p>JConsole </p><ul><li>内存监控</li><li>线程监控</li><li>死锁检测</li></ul></li><li><p>VisualVM 需下载</p></li></ul><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><h3 id="案例1：绩效考核系统"><a href="#案例1：绩效考核系统" class="headerlink" title="案例1：绩效考核系统"></a>案例1：绩效考核系统</h3><h4 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h4><p>64G， 2个intel E5 CPU<br>tomcat7， jdk7<br>堆内存设置了50G  </p><h4 id="问题：经常卡顿"><a href="#问题：经常卡顿" class="headerlink" title="问题：经常卡顿"></a>问题：经常卡顿</h4><h4 id="处理思路："><a href="#处理思路：" class="headerlink" title="处理思路："></a>处理思路：</h4><ul><li><del>优化sql(不是每个功能慢了，是某个时间段慢了)</del></li><li><del>监控CPU</del></li><li>监控内存<ul><li>Full GC 20-30s</li></ul></li></ul><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>部署多个web容器，每个web容器堆内存设置为4G.用nginx负载。 这样解决了堆内存多大垃圾收集时间长。又不浪费内存。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>没有大对象，不经常Full GC，部署多个容器更好。否则单个容器分配大的内存更好。毕竟容器启动会有额外内存，硬盘开销。</p><h3 id="案例2：数据抓取系统"><a href="#案例2：数据抓取系统" class="headerlink" title="案例2：数据抓取系统"></a>案例2：数据抓取系统</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>jdk5， 2G内存， intel core i3， win server</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>不定期内存溢出，堆内存加大也无济于事，导出堆快照，没人信息。内存监控，正常</p><h4 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h4><p>捕获到了bytebuffer。系统用了很多NIO。direct memory改大一些。</p><h3 id="案例3：物联网应用"><a href="#案例3：物联网应用" class="headerlink" title="案例3：物联网应用"></a>案例3：物联网应用</h3><p>JVM崩溃。 Connect Reset  </p><p>任务挤压，大量未处理任务导致<br>解决：加消息队列</p><hr><h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><p>编译器编译产生的。字节码文件<br>.class文件需要二进制编辑器打开。比如binary viewer</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列。中间没有任何分隔符。<br>Class文件中有两种数据类型：无符号数和表。 </p><p>第一行前8位是魔数，后8位是版本号。<br>魔数: class文件的标识，CA FE BA BE， 魔数后面8位为版本号：JDK1.8 = 52， JDK1.7 = 51  </p><p>常量池<br>访问标志<br>类索引，弗雷索引，接口索引集合<br>字段表集合<br>方法表集合<br>属性表集合   </p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h4 id="自定义类加载"><a href="#自定义类加载" class="headerlink" title="自定义类加载"></a>自定义类加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String path;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String path, String name) &#123;</span><br><span class="line">        this.path = path;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class findClass(String name) &#123;</span><br><span class="line"></span><br><span class="line">        byte[] b = loadClassData(name);</span><br><span class="line">        return defineClass(name, b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加载类文件二进制字节码</span><br><span class="line">    private byte[] loadClassData(String name) &#123;</span><br><span class="line">        name = path + name + &quot;.class&quot;;</span><br><span class="line">        InputStream in = null;</span><br><span class="line">        ByteArrayOutputStream out = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new FileInputStream(new File(name));</span><br><span class="line">            out = new ByteArrayOutputStream();</span><br><span class="line">            int i = 0;</span><br><span class="line">            while ((i = in.read()) != -1) &#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderCheck &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        MyClassLoader myClassLoader = new MyClassLoader(&quot;/Users/yuan/Desktop/&quot;, &quot;myClassLoader&quot;);</span><br><span class="line">        Class clazz = myClassLoader.findClass(&quot;Bot&quot;);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类:"></a>类加载器分类:</h4><ul><li>BootStrapClassLoader: C++编写，加载核心库java</li><li>ExtClassLoader: Java编写，加载扩展库javax.*</li><li>AppClassLoader: Java编写，加载程序所在目录</li><li>自定义ClassLoader: Java编写，定制化加载</li></ul><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>自底向上查找，自上向下加载;代码的loadclass中，加载类时，循环判断父加载器不为空就先尝试加载父加载器，直到加载C++编写的BootStrapClassLoader。 <code>CustomClassLoader-&gt;AppClassLoader-&gt;ExtClassLoader-&gt;BooStrapClassLoader</code><br>类本身+类加载器唯一确定在jvm  的唯一性。所以自定义加载同类名的类，无法加载<br><a href="https://www.jianshu.com/p/353c26c744df" target="_blank" rel="noopener">参考</a></p><h4 id="为什么用双亲委派模型"><a href="#为什么用双亲委派模型" class="headerlink" title="为什么用双亲委派模型?"></a>为什么用双亲委派模型?</h4><p>每个类加载器是一个类加载空间，隔开的各个类的加载优先级；</p><ul><li>避免多份同样的字节码的加载，逐层去查找</li></ul><h4 id="loadClass-forName的区别"><a href="#loadClass-forName的区别" class="headerlink" title="loadClass, forName的区别"></a>loadClass, forName的区别</h4><ul><li>加载class文件字节码，生成Class对象</li><li>校验(正确和安全)、准备(为类变量分配空间并设置变量初始值)、解析(JVM常量池的符号引用转为直接引用)</li><li>初始化(执行类变量赋值和静态代码块)</li></ul><p>forName是加载类并已完成了初始化(比如执行静态代码块); loadClass没有链接的</p><h4 id="三大性能调优参数-Xms-Xmx-Xss的含义"><a href="#三大性能调优参数-Xms-Xmx-Xss的含义" class="headerlink" title="三大性能调优参数 -Xms -Xmx -Xss的含义"></a>三大性能调优参数 -Xms -Xmx -Xss的含义</h4><ul><li>-Xss: 规定每个线程虚拟机栈的大小，影响并发线程数的大小</li><li>-Xms: 堆的初始值</li><li>-Xmx: 堆能达到的最大值<blockquote><p>一般-Xms与-Xmx设置成一样大小，防止扩容时的抖动</p></blockquote></li></ul><h4 id="Java内存模型中堆和栈的区别-内存分配策略"><a href="#Java内存模型中堆和栈的区别-内存分配策略" class="headerlink" title="Java内存模型中堆和栈的区别-内存分配策略"></a>Java内存模型中堆和栈的区别-内存分配策略</h4><ul><li>静态存储: 编译时确定每个数据目标在运行时的存储空间需求</li><li>栈式存储: 数据区需求在编译时未知，运行时模块入口前确定</li><li>堆式存储: 编译时或运行时模块入口都无法确定，动态分配</li><li>管理方式: 栈自动释放，堆需要GC</li><li>空间大小: 栈比堆小</li><li>碎片相关: 栈产生的碎片远小于堆</li><li>分配方式: 栈支持静态和动态分配，堆只支持动态分配</li><li>效率: 栈效率比堆高</li></ul><h4 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h4><p>如果常量池中不存在，则把字符串放到常量池中，存在则直接返回其引用；<br>JDK6以上:除了检查常量池是否存在，还检查堆中是否存在，如果存在则将对象的引用放在常量池并返回</p><h4 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h4><p>线程私有:</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p>线程共享:</p><ul><li>堆(JDK6以上: 常量池放在堆中，之前在永久代，频繁创建放到常量池容易OOM: PermGen spcae)</li><li>MetaSpace: 类加载信息</li></ul><h4 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h4><ul><li>虚拟机栈中引用的对象(栈帧中的本地变量表)</li><li>方法区中的常量引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>本地方法栈中JNI(Native方法)的引用对象</li><li>活跃线程的引用对象</li></ul><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><ul><li>标记-清除</li><li>复制: 解决碎片化问题</li><li>标记-整理</li><li>分代收集<blockquote><p>JDK8以后取消了永代，可以减少Full GC的频率</p></blockquote></li></ul><h4 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h4><p>…</p><h4 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h4><ul><li>强引用(Strong Reference)<ul><li>Object obj = new Object()</li><li>抛出OOM也不会回收这个内存</li></ul></li><li><p>软引用(Soft Reference)</p><ul><li>对象处于有用但非必须的状态</li><li>只有空间不足时，才会回收这个对象内存</li><li>可以实现高速缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str= new String(&quot;a&quot;)</span><br><span class="line">SoftReference&lt;String&gt; s = new SoftReference&lt;String&gt;(str) //软引用</span><br></pre></td></tr></table></figure></li></ul></li><li><p>弱引用(Weak Reference)</p><ul><li>非必须对象，比软引用更弱</li><li>GC时被回收</li><li>被回收的概率不大，因为回收的优先级比较低</li><li>适用于偶尔会适用，不影响GC垃圾收集的对象</li></ul></li><li>虚引用(Phntom Reference)<ul><li>不会决定对象的生命周期</li><li>任何时候都能被回收</li><li>跟踪垃圾回收期回收活动，起到哨兵作用</li><li>必须和引用队列ReferenceQueue联合使用</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>logback kafka输出日志到ELK</title>
      <link href="/logback-kafka%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E5%88%B0ELK/"/>
      <url>/logback-kafka%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E5%88%B0ELK/</url>
      
        <content type="html"><![CDATA[<p>详细步骤，Spring日志通过logstash、kafka打印到ELK，方便查阅<br><a id="more"></a></p><blockquote><p>参考 <a href="https://www.jianshu.com/p/d1be3364f32d" target="_blank" rel="noopener">logback+kafka+elk搭建日志</a>, 学习总结</p></blockquote><blockquote><p>日志流程: logback -&gt; kafka -&gt; logstash -&gt; elasticsearch -&gt; kibana</p></blockquote><h3 id="kafka安装启动"><a href="#kafka安装启动" class="headerlink" title="kafka安装启动"></a>kafka安装启动</h3><ul><li><a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">官方下载</a>， 选择Binary downloads下载</li><li>先启动zookeeper<br><code>bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></li><li>启动kafka<br><code>bin/kafka-server-start.sh config/server.properties &amp;</code><h3 id="logback与kafka集成"><a href="#logback与kafka集成" class="headerlink" title="logback与kafka集成"></a>logback与kafka集成</h3>kafka与logback使用的是 <a href="https://github.com/danielwegener/logback-kafka-appender" target="_blank" rel="noopener">logback-kafka-appender</a></li><li><p>引入pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--kafka依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--logback-kafka-appender依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.danielwegener<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-kafka-appender<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0-RC2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置<code>logback-spring.xml</code>:</p><blockquote><p>SpringBoot加载顺序: <code>logback-spring.xml&gt; logback-spring.groovy&gt; logback.xml&gt; logback.groovy</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>  <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span> <span class="attr">value</span>=<span class="string">"/data/logs"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--输出到控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"kafkaAppender"</span> <span class="attr">class</span>=<span class="string">"com.github.danielwegener.logback.kafka.KafkaAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">topic</span>&gt;</span>applog<span class="tag">&lt;/<span class="name">topic</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- we don't care how the log messages will be partitioned  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">keyingStrategy</span> <span class="attr">class</span>=<span class="string">"com.github.danielwegener.logback.kafka.keying.NoKeyKeyingStrategy"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- use async delivery. the application threads are not blocked by logging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">deliveryStrategy</span> <span class="attr">class</span>=<span class="string">"com.github.danielwegener.logback.kafka.delivery.AsynchronousDeliveryStrategy"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- each &lt;producerConfig&gt; translates to regular kafka-client config (format: key=value) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- producer configs are documented here: https://kafka.apache.org/documentation.html#newproducerconfigs --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- bootstrap.servers is the only mandatory producerConfig --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>bootstrap.servers=localhost:9092<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- don't wait for a broker to ack the reception of a batch.  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>acks=0<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- wait up to 1000ms and collect log messages before sending them as a batch --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>linger.ms=1000<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- even if the producer buffer runs full, do not block the application but start to drop messages --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>max.block.ms=0<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- define a client-id that you use to identify yourself against the kafka broker --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">producerConfig</span>&gt;</span>client.id=$&#123;HOSTNAME&#125;-$&#123;CONTEXT_NAME&#125;-logback-relaxed<span class="tag">&lt;/<span class="name">producerConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"kafkaAppender"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="logstash配置启动"><a href="#logstash配置启动" class="headerlink" title="logstash配置启动"></a>logstash配置启动</h3><blockquote><p>ELK的安装使用可以参考 <a href="https://blog.csdn.net/ysw1132/article/details/84941747" target="_blank" rel="noopener">ELK安装使用</a></p><ul><li>配置kafka接收数据，输出到es, index是 test-kafka<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">     kafka &#123;</span><br><span class="line">        topics =&gt; "applog"</span><br><span class="line">        bootstrap_servers =&gt; "localhost:9092"</span><br><span class="line">        group_id =&gt; "es"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; "localhost:9200"</span><br><span class="line">    index =&gt; "test-kafka"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li>启动<br><code>./bin/logstash -f test-kafka.conf</code><h3 id="elasticsearch启动"><a href="#elasticsearch启动" class="headerlink" title="elasticsearch启动"></a>elasticsearch启动</h3><code>./bin/elasticsearch</code></li></ul><h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><p><code>./bin/kibana</code></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul><li>启动程序输出日志<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogKafkaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SpringApplication.run(LogKafkaApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            log.info(<span class="string">"log to kafka..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>访问 <code>http://127.0.0.1:5601</code>, 在<code>test-kafka</code>下出现了日志,如图<br><img src="https://img-blog.csdnimg.cn/20190223161033739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzdzExMzI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 工具框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring 多数据源</title>
      <link href="/Spring-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
      <url>/Spring-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>Spring多数据源的简单概述<br><a id="more"></a></p><p>application.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">spring.output.ansi.enabled=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo.datasource.url=jdbc:h2:mem:foo</span><br><span class="line">foo.datasource.username=sa</span><br><span class="line">foo.datasource.password=</span><br><span class="line"></span><br><span class="line">bar.datasource.url=jdbc:h2:mem:bar</span><br><span class="line">bar.datasource.username=sa</span><br><span class="line">bar.datasource.password=</span><br></pre></td></tr></table></figure></p><p>Application.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = &#123;DataSourceAutoConfiguration.class,</span><br><span class="line">        DataSourceTransactionManagerAutoConfiguration.class,</span><br><span class="line">        JdbcTemplateAutoConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"foo.datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">fooDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">fooDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DataSourceProperties dataSourceProperties = fooDataSourceProperties();</span><br><span class="line">        log.info(<span class="string">"foo dataSource: [&#123;&#125;]"</span>, dataSourceProperties.getUrl());</span><br><span class="line">        <span class="keyword">return</span> dataSourceProperties.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">fooTxManager</span><span class="params">(DataSource fooDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(fooDataSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"bar.datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">barDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">barDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DataSourceProperties dataSourceProperties = barDataSourceProperties();</span><br><span class="line">        log.info(<span class="string">"bar dataSource: [&#123;&#125;]"</span>, dataSourceProperties.getUrl());</span><br><span class="line">        <span class="keyword">return</span> dataSourceProperties.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">barTxManager</span><span class="params">(DataSource barDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(fooDataSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>忽略springboot自动配置的数据源部分，自己配置</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的 Intelij Idea 配置</title>
      <link href="/%E6%88%91%E7%9A%84-Intelij-Idea-%E9%85%8D%E7%BD%AE/"/>
      <url>/%E6%88%91%E7%9A%84-Intelij-Idea-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>我常用的Idea字体，插件等配置，欢迎查阅<br><a id="more"></a></p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><blockquote><p>在 Preference/Editor/File and Code Templates</p><ul><li>Class<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end</span><br><span class="line">#set($myName = &apos;xxx&apos;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * $&#123;DESCRIPTION&#125;</span><br><span class="line"> * @author $&#123;myName&#125;</span><br><span class="line"> * @date $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125;</span><br><span class="line"> */</span><br><span class="line">public class $&#123;NAME&#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p>Interface</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end</span><br><span class="line">#set($myName = &apos;xxx&apos;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * $&#123;DESCRIPTION&#125;</span><br><span class="line"> * @author $&#123;myName&#125;</span><br><span class="line"> * @date $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125;</span><br><span class="line"> */</span><br><span class="line">#parse(&quot;File Header.java&quot;)</span><br><span class="line">public interface $&#123;NAME&#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Enum</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end</span><br><span class="line">#set($myName = &apos;xxx&apos;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * $&#123;DESCRIPTION&#125;</span><br><span class="line"> * @author $&#123;myName&#125;</span><br><span class="line"> * @date $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125;</span><br><span class="line"> */</span><br><span class="line">#parse(&quot;File Header.java&quot;)</span><br><span class="line">public enum $&#123;NAME&#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote><p>在 Preference/Editor/Font</p></blockquote><p>很喜欢mac字体Menlo，windows可自行下载字体安装，逐个点击字体文件安装即可</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><a href="https://plugins.jetbrains.com/plugin/6317-lombok-plugin" target="_blank" rel="noopener">Lombok</a> : 简化Java代码，自动生产Setter、Getter等，详情见<a href="https://projectlombok.org/" target="_blank" rel="noopener">官网</a></li><li><a href="https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin" target="_blank" rel="noopener">Free Mybatis</a> :可以将Mapper.java与xml文件关联起来，点击可以跳转到对应的方法中</li><li><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper" target="_blank" rel="noopener">Maven Helper</a> :maven解决冲突，查看maven引用tree</li><li><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines" target="_blank" rel="noopener">Alibaba Java Coding Guidelines</a> : 阿里代码规约，根据阿里代码规约自动提示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【kong二】kong的简单使用-konga</title>
      <link href="/%E3%80%90kong%E4%BA%8C%E3%80%91kong%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8-konga/"/>
      <url>/%E3%80%90kong%E4%BA%8C%E3%80%91kong%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8-konga/</url>
      
        <content type="html"><![CDATA[<p>通过konga简单的配置kong，的使用过程<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20181228142514513.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzdzExMzI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图，</p><ul><li>Upstream Url: 重定向的地址是实际的接口地址，或者upstreams地址(此时upstream配合多台机器接口，可做负载均衡)</li><li>Hosts:kong主机ip</li><li>Uris：访问地址</li><li>此时我们访问http://{hosts}:8000/Uris，则指向了Upstream URL</li></ul><h3 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h3><ul><li>1.配置UPSTREAMS<br>新建一个UPSTREAMS，在其下增加多个Targets：Target配置为ip:port,修改Weight权重</li></ul><ul><li>2.配置APIS<br>新建APIS，配置填写如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;test&quot;,</span><br><span class="line">    &quot;host&quot;:&quot;$&#123;kong所在主机ip&#125;&quot;,</span><br><span class="line">    &quot;Uris&quot;:&quot;/api/test&quot;,</span><br><span class="line">    &quot;Upstream URL&quot;:&quot;http://$&#123;UPSTREAMS.name&#125;/api/test&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>kong访问地址: </p><blockquote><p>http://${kong主机}:8000/${Uris}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【kong一】kong安装与konga</title>
      <link href="/%E3%80%90kong%E4%B8%80%E3%80%91kong%E5%AE%89%E8%A3%85%E4%B8%8Ekonga/"/>
      <url>/%E3%80%90kong%E4%B8%80%E3%80%91kong%E5%AE%89%E8%A3%85%E4%B8%8Ekonga/</url>
      
        <content type="html"><![CDATA[<p>kong的详细安装过程，以及通过konga管理台管理<br><a id="more"></a><br>环境</p><blockquote><p>ubuntu</p></blockquote><h3 id="一、安装PostgreSql"><a href="#一、安装PostgreSql" class="headerlink" title="一、安装PostgreSql"></a>一、安装PostgreSql</h3><p>kong需要用到数据库，目前支持<br><a href="http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html" target="_blank" rel="noopener">psql安装过程参考</a><br>安装完成创建一个用户:kong，密码:kong，数据库:kong</p><h3 id="二、安装Kong"><a href="#二、安装Kong" class="headerlink" title="二、安装Kong"></a>二、安装Kong</h3><h4 id="1-文件下载"><a href="#1-文件下载" class="headerlink" title="1. 文件下载"></a>1. <a href="https://getkong.org/install/ubuntu/" target="_blank" rel="noopener">文件下载</a></h4><h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openssl libpcre3 procps perl</span><br><span class="line">sudo dpkg -i kong-community-edition-0.11.0.*.deb</span><br></pre></td></tr></table></figure><h4 id="3-修改数据库配置文件"><a href="#3-修改数据库配置文件" class="headerlink" title="3. 修改数据库配置文件"></a>3. 修改数据库配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/kong/kong.conf.default /etc/kong/kong.conf</span><br><span class="line">vim /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pg_host = 127.0.0.1             # The PostgreSQL host to connect to.</span><br><span class="line">pg_port = 5432                  # The port to connect to.</span><br><span class="line">pg_user = kong                  # The username to authenticate if required.</span><br><span class="line">pg_password = kong              # The password to authenticate if required.</span><br><span class="line">pg_database = kong</span><br></pre></td></tr></table></figure></p><h4 id="4-启动"><a href="#4-启动" class="headerlink" title="4. 启动"></a>4. 启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kong migrations up</span><br><span class="line">kong start</span><br></pre></td></tr></table></figure><h4 id="5-验证"><a href="#5-验证" class="headerlink" title="5. 验证"></a>5. 验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8001</span><br></pre></td></tr></table></figure><p>输出大段json信息说明成功</p><h4 id="6-端口说明"><a href="#6-端口说明" class="headerlink" title="6. 端口说明"></a>6. 端口说明</h4><p>8000端口：外部调用api端口，比如设置Urlis=/test, 则访问地址是:  http://[IP]:8000/test<br>8001端口: api 管理端口，可通过restful接口管理kong</p><h4 id="7-文档"><a href="#7-文档" class="headerlink" title="7. 文档"></a>7. 文档</h4><p><a href="https://docs.konghq.com/" target="_blank" rel="noopener">https://docs.konghq.com/</a></p><h3 id="三、安装Konga"><a href="#三、安装Konga" class="headerlink" title="三、安装Konga"></a>三、安装Konga</h3><p>说明：</p><blockquote><ul><li>官网推荐: <a href="https://github.com/PGBI/kong-dashboard" target="_blank" rel="noopener">kong-dashboard</a>，但对比界面高端程度和友好度，更推荐konga.</li><li>[一个坑]kong版本问题：我在安装时目前kong最新版本已经到1.0.0, 对于konga和kong-dashboard还不支持，建议安装低版本0.15以下; 具体表现查询apis，旧版本:[ip]:8001/apis,新版:[ip]:8001/services</li></ul></blockquote><h4 id="npm安装方式"><a href="#npm安装方式" class="headerlink" title="npm安装方式"></a>npm安装方式</h4><h4 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs npm</span><br><span class="line">sudo npm install -g gulp</span><br><span class="line">sudo npm install -g bower</span><br><span class="line">sudo npm install -g sails</span><br></pre></td></tr></table></figure><h4 id="2-安装-1"><a href="#2-安装-1" class="headerlink" title="2. 安装"></a>2. 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pantsel/konga.git</span><br><span class="line">cd konga</span><br><span class="line">npm install konga</span><br></pre></td></tr></table></figure><h4 id="3-配置数据库信息"><a href="#3-配置数据库信息" class="headerlink" title="3. 配置数据库信息"></a>3. 配置数据库信息</h4><p>目前支持数据库: mysql, mongo, sqlserver, postgres<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd config/</span><br><span class="line">cp local_example.js local.js</span><br><span class="line">vi local.js</span><br><span class="line"></span><br><span class="line">models: &#123;</span><br><span class="line">    connection: process.env.DB_ADAPTER || 'localDiskDb',</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span> 改成</span><br><span class="line">models: &#123;</span><br><span class="line">    connection: process.env.DB_ADAPTER || 'mysql', // 这里可以用‘mysql’，‘mongo’，‘sqlserver’，‘postgres’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 修改数据库默认配置</span><br><span class="line">vi konga/config/connections.js</span><br><span class="line">mysql: &#123;</span><br><span class="line">    adapter: 'sails-mysql',</span><br><span class="line">    host: process.env.DB_HOST || 'localhost',</span><br><span class="line">    port: process.env.DB_PORT || 3306,</span><br><span class="line">    user: process.env.DB_USER || 'root',</span><br><span class="line">    password: process.env.DB_PASSWORD || null,</span><br><span class="line">    database: process.env.DB_DATABASE || 'konga_database'</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span> 改成</span><br><span class="line">mysql: &#123;</span><br><span class="line">    adapter: 'sails-mysql',</span><br><span class="line">    host: process.env.DB_HOST || 'localhost',</span><br><span class="line">    port: process.env.DB_PORT || 3306,</span><br><span class="line">    user: process.env.DB_USER || 'root',</span><br><span class="line">    password: process.env.DB_PASSWORD || 'root',</span><br><span class="line">    database: process.env.DB_DATABASE || 'konga_database'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装依赖<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run bower-deps</span><br><span class="line">npm install dotenv-extended</span><br><span class="line">npm install angular</span><br></pre></td></tr></table></figure></p><p>启动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>konga根目录</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure></p><p>访问: <a href="http://127.0.0.1:1338" target="_blank" rel="noopener">http://127.0.0.1:1338</a><br><img src="https://img-blog.csdnimg.cn/20181228114218994.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzdzExMzI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 工具框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>openresty mac 安装与使用</title>
      <link href="/openresty-mac-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/openresty-mac-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>openresty详细安装步骤<br><a id="more"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>依赖安装    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install pcre openssl</span><br></pre></td></tr></table></figure><ol start="2"><li>安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install homebrew/nginx/openresty</span><br></pre></td></tr></table></figure></li></ol></li><li><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/local/opt/openresty/nginx/sbin:$PATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure></li></ol><p>3.启动查看<br>查看版本信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure></p><p>启动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20181224114653561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzdzExMzI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>常用命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">启动:nginx</span><br><span class="line">停止:nginx -s stop   停止nginx也停止了openresty</span><br><span class="line">重启:nginx -s reload</span><br><span class="line">检验nginx配置是否正确: nginx -t</span><br></pre></td></tr></table></figure></p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><ul><li><p>创建测试目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/openresty-test ~/openresty-test/logs/ ~/openresty-test/conf/</span><br></pre></td></tr></table></figure></li><li><p>在conf文件下创建nginx.conf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">error_log logs/error.log;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8088;</span><br><span class="line">        location / &#123;</span><br><span class="line">            default_type text/html;</span><br><span class="line">            content_by_lua '</span><br><span class="line">                ngx.say("hello lua")</span><br><span class="line">            ';</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>nginx -p ${pwd} -c conf/nginx.conf </p></li><li>访问 <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> openresty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo更新博客-原始文件与静态文件</title>
      <link href="/Hexo%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2-%E5%8E%9F%E5%A7%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/"/>
      <url>/Hexo%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2-%E5%8E%9F%E5%A7%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过Hexo发布的博客，通过本地原始文件 “hexo g -d” 将生成的静态文件发布到github上，原始文件留在了本地。这样无法在其他电脑或文件丢失情况下更新发布博客。<br><a id="more"></a></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>利用github的分支，创建两个分支master和hexo；  hexo分支存储原始文件，master存储博客静态页面，原始文件push到hexo分支，而静态文件直接发布到了master分支。<br>_config.yml中的deploy参数，分支应为master。</p><h2 id="日常博客修改"><a href="#日常博客修改" class="headerlink" title="日常博客修改"></a>日常博客修改</h2><p>包括新博文和样式的修改  </p><p>1.提交原始文件到分支hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -am &quot;&quot;</span><br><span class="line">git commit origin hexo</span><br></pre></td></tr></table></figure></p><p>2.发布网站到master分支上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></p><blockquote><p>注意顺序</p></blockquote><h2 id="在没有原始文件的电脑上修改"><a href="#在没有原始文件的电脑上修改" class="headerlink" title="在没有原始文件的电脑上修改"></a>在没有原始文件的电脑上修改</h2><ol><li>拉hexo分支的原始代码到本地</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ...</span><br></pre></td></tr></table></figure><ol start="2"><li>下载npm包(需要有node环境)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><blockquote><p>不需要 hexo init</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK安装使用</title>
      <link href="/ELK%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/ELK%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>ELK安装详细步骤，欢迎参考<br><a id="more"></a></p><h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><blockquote><p>需要java环境</p></blockquote><p><a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="noopener">官方下载地址</a><br>cd [logstash主目录]<br>vim test.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"> stdin &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"> stdout &#123;</span><br><span class="line"> codec =&gt; rubydebug &#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行: bin/logstash -f test.conf<br>测试结果<br><img src="https://img-blog.csdnimg.cn/20181210155547275.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzdzExMzI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面结果表示成功</p><h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><p><a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">官方下载地址</a><br>cd [elasticsearch主目录]<br>vim config/elasticsearch.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path.data: /data/es #数据路径</span><br><span class="line">path.logs: /data/logs/es #日志路径</span><br><span class="line">network.host: 本机地址 #服务器地址</span><br><span class="line">http.port: 9200 #端口</span><br></pre></td></tr></table></figure></p><p>启动: bin/elasticsearch<br><img src="https://img-blog.csdnimg.cn/20181210155946530.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzdzExMzI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="集成logstash和elasticsearch"><a href="#集成logstash和elasticsearch" class="headerlink" title="集成logstash和elasticsearch"></a>集成logstash和elasticsearch</h2><p>修改logstash配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"> stdin &#123; &#125; </span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"> elasticsearch &#123;</span><br><span class="line"> hosts =&gt; &quot;elasticsearchIP:9200&quot;</span><br><span class="line"> index =&gt; &quot;logstash-test&quot;</span><br><span class="line"> &#125; </span><br><span class="line"> stdout &#123;</span><br><span class="line"> codec =&gt; rubydebug &#123;&#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再次启动logstash, 输入”hello elasticsearch”</p><p><img src="https://img-blog.csdnimg.cn/2018121016052219.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzdzExMzI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><p><a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="noopener">官方下载地址</a><br>cd [kibana主目录]<br>vim config/kibana.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601 #kibana端口</span><br><span class="line">server.host: “本机ip” #kibana的ip</span><br><span class="line">elasticsearch.url: “http://elasticsearchIP:9200” #elasticsearch地址</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20181210160927279.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzdzExMzI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>SpringBoot-ELK demo: <a href="https://howtodoinjava.com/microservices/elk-stack-tutorial-example/" target="_blank" rel="noopener">推荐</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合总述</title>
      <link href="/Java-Collection/"/>
      <url>/Java-Collection/</url>
      
        <content type="html"><![CDATA[<p>整体总结概述各集合特点，底层数据结构<br><a id="more"></a></p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>Collection<ul><li><strong>List</strong><ul><li><code>ArrayList</code>:<br>Object数组实现，每次扩容为原来的1.5倍；非线程安全；</li><li><code>Vector</code> :<br>Object数组实现，相对ArrayList，用synchronized关键字加锁，实现线程安全；</li><li><code>LinkedList</code>:<br>双向循环链表；非线程安全；</li></ul></li><li><strong>Map</strong><ul><li><code>HashMap</code>:<br>存储&lt;K,V&gt;对象，用K计算的hash值匹配到bucket，K.equals()定位具体的&lt;K,V&gt;对象来找到value；负载因子0.75，也就是说容量达到75%时扩容，初始16，每次扩容变为原来的2倍。</li><li><code>Hashtable</code>:<br>遗留类，基本被淘汰，放入null会报错。它是在HashMap基础加了synchronized关键字，所以并发性不好；替代的推荐用ConcurrentHashMap</li><li><code>LinkedHashMap</code>:<br>HashMap的一个子类；链表实现</li><li><code>TreeMap</code>：<br>TreeMap实现SortedMap接口，保存的是按key排序的，默认是按key升序排序，也可以指定排序；</li><li><code>ConcurrentHashMap</code>:<br>JDK1.8 中取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。不允许键值null；</li></ul></li><li><strong>Set</strong> <ul><li><code>HashSet</code>:<br>无序，唯一；基于 HashMap 实现的，底层采用 HashMap 来保存元素；判断对象重复的方式与HashMap判断K的hash然后equals一致；</li><li><code>TreeSet</code>：<br>有序，唯一；红黑树</li><li><code>LinkedHashSet</code>：<br>基于LinkedHashMap实现</li></ul></li></ul></li></ul><blockquote><p>推荐: <a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">源码学习</a></p></blockquote><h4 id="HashMap分析"><a href="#HashMap分析" class="headerlink" title="HashMap分析"></a>HashMap分析</h4><ul><li>允许键值为null；  </li><li>非线程安全；如果需要满足线程安全，可以用 Collections.synchronizedMap()方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。  </li><li>JDK1.7前，以数组+链表的链表数组存储，数组是主体，链表是为了解决hash冲突的存在。存储的结构是&lt;K,V&gt;的实体，以K的hash值定位到bucket，发生hash冲突是通过K.equals()找到需要的实体部分。  </li><li>JDK1.8，当链表长度&gt;8时，链表转换为红黑树，当链表长度&lt;6，红黑树转为链表。另外改进了hash计算方法，使得分布更加均匀</li></ul><h5 id="为什么HashMap长度是2的N次？"><a href="#为什么HashMap长度是2的N次？" class="headerlink" title="为什么HashMap长度是2的N次？"></a>为什么HashMap长度是2的N次？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&amp;(length-1)，</span><br><span class="line">hash%length==hash&amp;(length-1)的前提是length是2的n次方；</span><br><span class="line">为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</span><br><span class="line">例如长度为9时候，3&amp;(9-1)=0  2&amp;(9-1)=0 ，都在0上，碰撞了；</span><br><span class="line">例如长度为8时候，3&amp;(8-1)=3  2&amp;(8-1)=2 ，不同位置上，不碰撞；</span><br></pre></td></tr></table></figure><h5 id="为什么8节点变为红黑树？"><a href="#为什么8节点变为红黑树？" class="headerlink" title="为什么8节点变为红黑树？"></a>为什么8节点变为红黑树？</h5><ul><li><a href="https://blog.csdn.net/xingfei_work/article/details/79637878" target="_blank" rel="noopener">n/2与log(n)</a></li><li><a href="https://www.javazhiyin.com/34651.html" target="_blank" rel="noopener">概率统计得到</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java编程的逻辑-泛型</title>
      <link href="/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91-%E6%B3%9B%E5%9E%8B/"/>
      <url>/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>泛型是通过类型擦除实现的，类型参数会在编译时被替换为Object，运行时Java虚拟机不知道泛型这回事；<br><a id="more"></a><br>类泛型，方法泛型，接口泛型  </p></blockquote><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">U</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    U first;</span><br><span class="line">    v second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(U first, V second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> U <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面都是泛型方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T[] arr, T elm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(elm)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T,K&gt; <span class="function">K <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这不是一个泛型方法，这是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><t>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T; </t></li><li>只有声明了<t>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</t></li></ol></blockquote><h5 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure><h5 id="泛型方法静态方法"><a href="#泛型方法静态方法" class="headerlink" title="泛型方法静态方法"></a>泛型方法静态方法</h5><blockquote><p>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</p></blockquote><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现时传入具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>举例， 虽然Integer是Number的子类，但是Generic<number>和Generic<ingeter>并不能构成子类关系；可以使用下面的形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></ingeter></number></p><p>此处的 ‘?’ 是实参，可以把 ‘?’ 看成所有类型的父类。是一种真实的类型;   当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><p>两种写法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(DynamicArray&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T extends E&gt; <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(DynamicArray&lt;T&gt; c)</span></span></span><br></pre></td></tr></table></figure></p><p>通配符，允许读不允许写，比如下面，?是未知的类型，只知道是Number的子类，如果允许写，Java无法保证类型安全性所以干脆禁止写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 上界</span><br><span class="line">```java</span><br><span class="line">public class NumberPair&lt;U extends Number, V extends Number&gt; extends Pair&lt;U, V&gt; &#123;</span><br><span class="line">    public NumberPair(U first, V second) &#123;</span><br><span class="line">        super(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(T[] arr) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul><li><p>因为类型会被替换为Object，所以泛型不能使用基本的数据类型; 下面写法不合法，需使用对应的包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">int</span>&gt; minmax = <span class="keyword">new</span> Pair&lt;ing&gt;(<span class="number">1</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure></li><li><p>instanceof是运行时判断，与泛型无关</p></li><li><p>下面的例子重载不允许，因为类型擦除后它们的声明是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(DynamicArray&lt;Integer&gt; intArr)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(DynamicArray&lt;String&gt; intArr)</span></span></span><br></pre></td></tr></table></figure></li><li><p>不能用类型参数创建对象；如果允许用户以为创建的是对应类的对象，类型擦除后实际创建的是Object的对象，所以干脆禁止。 想要这么做可以用反射；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//都是非法的</span></span><br><span class="line">T elm = <span class="keyword">new</span> T();</span><br><span class="line">T[] arr = <span class="keyword">new</span> T[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li><li><p>不能用于静态变量</p></li><li>不支持创建泛型数据， Object[] -&gt; T[] 问题； 需要使用反射。Array.newInstance(Class, size)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring RestTemplate 使用与HttpClient</title>
      <link href="/Spring-RestTemplate-%E4%BD%BF%E7%94%A8%E4%B8%8EHttpClient/"/>
      <url>/Spring-RestTemplate-%E4%BD%BF%E7%94%A8%E4%B8%8EHttpClient/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h2><p>java请求网络资源通常用<code>HttpClient</code>等，Spring封装了库，提供更为简洁的资源请求方式<code>RestTemplate</code>。</p><a id="more"></a><h2 id="2-简单GET请求-HttpClient-RestTemplate"><a href="#2-简单GET请求-HttpClient-RestTemplate" class="headerlink" title="2.简单GET请求(HttpClient/RestTemplate)"></a>2.简单GET请求(HttpClient/RestTemplate)</h2><h3 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">HttpGet httpget = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">CloseableHttpResponse response = httpclient.execute(httpget);</span><br><span class="line"></span><br><span class="line">String result = <span class="keyword">null</span>;</span><br><span class="line">HttpEntity entity = response.getEntity();</span><br><span class="line"><span class="keyword">if</span> (entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = EntityUtils.toString(entity);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建议以注入方式使用</span></span><br><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">String result = restTemplate.getForObject(url, String.class);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p>对比下，明显RestTemplate方式更加优雅简洁；并提供方法将返回值映射为指定对象。</p><h2 id="3-Spring注入方式使用"><a href="#3-Spring注入方式使用" class="headerlink" title="3.Spring注入方式使用"></a>3.Spring注入方式使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientConfig</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        <span class="keyword">return</span> restTemplate;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-RestTemplate的其他方法"><a href="#4-RestTemplate的其他方法" class="headerlink" title="4.RestTemplate的其他方法"></a>4.RestTemplate的其他方法</h2><p><img src="http://img.blog.csdn.net/20180312173132182?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXN3MTEzMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><ul><li><code>getForObject</code>: 发送get请求，结果封装为指定对象。 提供class指定</li><li><code>getForEntity</code>: 发送get请求，结果为Entity类型。</li><li><code>postForObject</code>: 发送post请求，结果封装为指定对象</li><li><code>put</code>:</li><li><code>delete</code>:</li><li><code>exchange</code>:通用执行方法<br>…<h4 id="exchange发送POST，APPLICATION-JSON示例"><a href="#exchange发送POST，APPLICATION-JSON示例" class="headerlink" title="exchange发送POST，APPLICATION_JSON示例"></a>exchange发送POST，APPLICATION_JSON示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">HttpEntity&lt;String&gt; entity = <span class="keyword">new</span> HttpEntity&lt;&gt;(<span class="keyword">new</span> Gson().toJson(requestData), headers);</span><br><span class="line">ResponseEntity&lt;String&gt; response = restTemplate</span><br><span class="line">               .exchange(url, HttpMethod.POST, entity, String.class);</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-RestTemplate的请求301，302问题"><a href="#5-RestTemplate的请求301，302问题" class="headerlink" title="5.RestTemplate的请求301，302问题"></a>5.RestTemplate的请求301，302问题</h2><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>使用过程发现，遇到301请求不能自动转发问题。</p><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>想起了使用HttpClient过程，实现请求自动转发需要创建HttpClient时设置重定向策略。<br>翻阅资料发现了这一段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpComponentsClientHttpRequestFactory factory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory();</span><br><span class="line">HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">         .setRedirectStrategy(<span class="keyword">new</span> LaxRedirectStrategy())</span><br><span class="line">         .build();</span><br><span class="line"> factory.setHttpClient(httpClient);</span><br><span class="line"> restTemplate.setRequestFactory(factory);</span><br></pre></td></tr></table></figure><p>于是问题解决。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>查阅源码可见，<br><code>RestTemplate</code>执行请求时。创建(createRequest)了一个<code>HttpUriRequest</code>来完成请求。<code>createRequest</code>具体在<code>ClientHttpRequestFactory</code> 实现，而上面代码中的<code>HttpComponentsClientHttpRequestFactory</code>，这个工厂在创建请求时正好用的apache下 <code>httpClient</code>的参数。由此可见。上面代码底层是以HttpClient方式发送的请求。</p><h2 id="6-RestTemplate全部是以HttpClient方式请求的吗？"><a href="#6-RestTemplate全部是以HttpClient方式请求的吗？" class="headerlink" title="6.RestTemplate全部是以HttpClient方式请求的吗？"></a>6.RestTemplate全部是以HttpClient方式请求的吗？</h2><p>通过源码不难看到，默认<code>RestTemplate</code>使用的是<code>SimpleClientHttpRequestFactory</code>工厂。<br>追踪可见，默认它是以java.net下的<code>HttpURLConnection</code>方式发起的请求。<br>所以<code>RestTemplate</code>是支持多种方式发起请求的。<br>查看该工程的实现类可知，支持包括HttpClient, OkHttp等方式，如下图<br><img src="http://img.blog.csdn.net/20180312175218751?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXN3MTEzMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RestTemplate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python入门-基础语法笔记</title>
      <link href="/python-base-note/"/>
      <url>/python-base-note/</url>
      
        <content type="html"><![CDATA[<p>python基础语法，比较详细, 查阅和初学<br><a id="more"></a></p><h3 id="1-vi技巧："><a href="#1-vi技巧：" class="headerlink" title="1.vi技巧："></a>1.vi技巧：</h3><p>中英切换：shift<br>wq = x  </p><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h3><p>单行：#<br>多行：三个单引号或三个双引号<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">print("hello world")  </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><h3 id="3-编码"><a href="#3-编码" class="headerlink" title="3.编码"></a>3.编码</h3><p>文件中有中文，不管是否为注释，python2执行报错。<br>解决：程序首行加 #coding=utf-8 或 #*-* coding:utf-8 *-*  </p><h3 id="4-输入"><a href="#4-输入" class="headerlink" title="4.输入"></a>4.输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">"请输入名字："</span>)</span><br></pre></td></tr></table></figure><h3 id="5-输出"><a href="#5-输出" class="headerlink" title="5.输出"></a>5.输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"name is %s"</span>%name)   </span><br><span class="line">print(<span class="string">"name:%s, age:%d"</span>%(name,age))  </span><br><span class="line">print(<span class="string">"name:&#123;0&#125;, age:&#123;1&#125;"</span>.format(name,age)) <span class="comment">#(标号可不写，为默认顺序) </span></span><br><span class="line">print(<span class="string">"name:&#123;name&#125;, age:&#123;age&#125;"</span>.format(name = <span class="string">"ss"</span>,age = <span class="number">23</span>)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">print(<span class="string">'常量 PI 的值近似为 &#123;0:.3f&#125;。'</span>.format(math.pi)) <span class="comment">#常量 PI 的值近似为 3.142。</span></span><br><span class="line"></span><br><span class="line">table = &#123;<span class="string">'Google'</span>: <span class="number">1</span>, <span class="string">'Runoob'</span>: <span class="number">2</span>, <span class="string">'Taobao'</span>: <span class="number">3</span>&#125;</span><br><span class="line">print(<span class="string">'Runoob: &#123;0[Runoob]:d&#125;; Google: &#123;0[Google]:d&#125;; Taobao: &#123;0[Taobao]:d&#125;'</span>.format(table))</span><br><span class="line"><span class="comment">#Runoob: 2; Google: 1; Taobao: 3</span></span><br><span class="line"></span><br><span class="line">table = &#123;<span class="string">'Google'</span>: <span class="number">1</span>, <span class="string">'Runoob'</span>: <span class="number">2</span>, <span class="string">'Taobao'</span>: <span class="number">3</span>&#125;</span><br><span class="line">print(<span class="string">'Runoob: &#123;Runoob:d&#125;; Google: &#123;Google:d&#125;; Taobao: &#123;Taobao:d&#125;'</span>.format(**table))</span><br><span class="line"><span class="comment">#Runoob: 2; Google: 1; Taobao: 3</span></span><br></pre></td></tr></table></figure><h3 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = int(<span class="string">"3"</span>)</span><br></pre></td></tr></table></figure><h3 id="7-python2与python3"><a href="#7-python2与python3" class="headerlink" title="7.python2与python3"></a>7.python2与python3</h3><ul><li>编码。</li><li>python2中input的内容当做执行的内容，python3当做字符串。如a = input(“”). python2中的raw_input相当于python3中的input。  </li><li>python2 中支持 &lt;&gt; 是不等于的意思，python3不支持，应该 != 表示  </li></ul><h3 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8.运算符"></a>8.运算符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a"</span> * <span class="number">5</span> = <span class="string">"aaaaa"</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> = <span class="number">8</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br><span class="line"><span class="number">5</span> // <span class="number">2</span> = <span class="number">2</span> <span class="comment">#(取商)</span></span><br><span class="line"><span class="number">5</span> % <span class="number">2</span> = <span class="number">1</span> <span class="comment">#（取余）</span></span><br></pre></td></tr></table></figure><h3 id="9-逻辑运算符"><a href="#9-逻辑运算符" class="headerlink" title="9.逻辑运算符"></a>9.逻辑运算符</h3><p>and , or  </p><h3 id="10-流程"><a href="#10-流程" class="headerlink" title="10.流程"></a>10.流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> &gt; <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">2</span> == <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">"2"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"3"</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> 条件:  </span><br><span class="line">    执行</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i int str:  </span><br><span class="line"> 执行</span><br><span class="line"> </span><br><span class="line">注: i++,++i在python中不允许使用。</span><br></pre></td></tr></table></figure><h3 id="11-字符串-不可变"><a href="#11-字符串-不可变" class="headerlink" title="11.字符串(不可变)"></a>11.字符串(不可变)</h3><ul><li>格式化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">'a: %s, b:%s'</span> %s (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="string">'a: a, b: b'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;&#125;, &#123;&#125; and &#123;&#125;'</span>.format(<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>)</span><br><span class="line"><span class="string">'first, second and third'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;3&#125; &#123;0&#125; &#123;2&#125; &#123;1&#125; &#123;3&#125; &#123;0&#125;'</span>.format(<span class="string">'be'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'to'</span>)</span><br><span class="line"><span class="string">'to be or not to be'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;name&#125; is approximately &#123;value:.2f&#125;."</span>.format(value=pi,name=<span class="string">"π"</span>)</span><br><span class="line"><span class="string">'π is approximately 3.14.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3 中，同名可省略</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> e</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f"Euler's constant is roughly <span class="subst">&#123;e&#125;</span>."</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f"Euler's constant is roughly <span class="subst">&#123;e&#125;</span>."</span>.format(e=e)</span><br><span class="line"></span><br><span class="line"><span class="comment">#格式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'the number is &#123;num:f&#125;'</span>.format(num=<span class="number">2</span>)</span><br><span class="line"><span class="string">'the number is 2.000000'</span></span><br></pre></td></tr></table></figure><ul><li>类型转换：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int(<span class="string">"100"</span>), str(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><ul><li>长度：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(str)</span><br></pre></td></tr></table></figure><ul><li>字符串连接:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b + c  <span class="comment">#或者</span></span><br><span class="line">a = <span class="string">"===%s==="</span>%(b+c)  <span class="comment">#或者</span></span><br><span class="line">a = <span class="string">"===&#123;&#125;==="</span>.format(b+c)</span><br></pre></td></tr></table></figure><ul><li>切片：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"dasfaf"</span></span><br><span class="line">str[<span class="number">2</span>:<span class="number">4</span>] <span class="comment">#(取得2到3的),  </span></span><br><span class="line">str[<span class="number">2</span>:]  <span class="comment">#(到最后),  </span></span><br><span class="line">str[<span class="number">2</span>:<span class="number">-1</span>:<span class="number">2</span>] <span class="comment">#(步长2，隔一个取一个)</span></span><br></pre></td></tr></table></figure><ul><li>逆序:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"abcdefABCDEF"</span>  </span><br><span class="line">str[<span class="number">0</span>:]  <span class="comment"># out:"abcdefABCDEF"  </span></span><br><span class="line">str[<span class="number">-1</span>:]  <span class="comment"># out:"F"  </span></span><br><span class="line">str[<span class="number">-1</span>:<span class="number">0</span>]  <span class="comment"># out:""  </span></span><br><span class="line">str[<span class="number">-1</span>:<span class="number">0</span>:<span class="number">-1</span>]  <span class="comment"># out:"FEDCBAfedcb"  </span></span><br><span class="line">str[<span class="number">-1</span>::<span class="number">-1</span>], str[::<span class="number">-1</span>]  <span class="comment"># out:"FEDCBAfedcba"</span></span><br></pre></td></tr></table></figure><ul><li>常见操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">find: str.find(<span class="string">"abc"</span>) <span class="comment"># 从左向右有返回第一个匹配字符串的起始下标，没有返回-1。rfind():从右向左。  </span></span><br><span class="line">str.index(<span class="string">"abc"</span>) <span class="comment">#找到返回起始下标，没有抛出异常。 存在rindex().  </span></span><br><span class="line">str.count(<span class="string">"abc"</span>) <span class="comment">#匹配的个数。</span></span><br><span class="line"></span><br><span class="line">str.replace(<span class="string">"abc"</span>, <span class="string">"def"</span>) <span class="comment">#把左边的替换成右边的同java，  </span></span><br><span class="line">str.replace(<span class="string">"abc"</span>, <span class="string">"def"</span>,<span class="number">1</span>) <span class="comment">#第三个参数是从左到右替换个数。  </span></span><br><span class="line"></span><br><span class="line">str.split(<span class="string">" "</span>) <span class="comment">#字符串分割   </span></span><br><span class="line">str.capitalize() <span class="comment">#字符串的第一个字母大写。  </span></span><br><span class="line">str.title() <span class="comment">#字符串的每个单词的首字母大写。  </span></span><br><span class="line">str.startswith(<span class="string">"abc"</span>), str.endswith(<span class="string">"abc"</span>) <span class="comment">#是否以此字符串开头或结尾.  </span></span><br><span class="line">str.lower() str.uper() <span class="comment">#所有的字母小写和大写。  </span></span><br><span class="line">str.center(<span class="number">50</span>) <span class="comment">#居中显示，行总长50 "     abc     " </span></span><br><span class="line">str.ljust(<span class="number">50</span>), str.rjust(<span class="number">50</span>) <span class="comment">#左(右)对齐</span></span><br><span class="line"></span><br><span class="line">str.lstrip() <span class="comment">#删除左边空格</span></span><br><span class="line">str.rstrip() <span class="comment">#右边空格</span></span><br><span class="line">str.strip() <span class="comment">#删除两端空格.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#center居中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'hello world'</span>.center(<span class="number">20</span>)</span><br><span class="line"><span class="string">'    hello world     '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'hello world'</span>.center(<span class="number">20</span>, <span class="string">'*'</span>)</span><br><span class="line"><span class="string">'****hello world*****'</span></span><br></pre></td></tr></table></figure><h3 id="12-列表-类似数组，可变，针对自身的变化"><a href="#12-列表-类似数组，可变，针对自身的变化" class="headerlink" title="12.列表  (类似数组，可变，针对自身的变化)"></a>12.列表  (类似数组，可变，针对自身的变化)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"zhangsan"</span>,<span class="string">"lisi"</span>]</span><br><span class="line"><span class="comment">#定义</span></span><br><span class="line">names = [<span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="number">3.14</span>]  <span class="comment">#列表中的数据可以是不同的数据类型。  可以下标，和切片。</span></span><br><span class="line"><span class="comment">#增</span></span><br><span class="line">names.append(<span class="string">"abc"</span>) <span class="comment">#--&gt;插入到最后;  </span></span><br><span class="line">names.insert(<span class="number">0</span>, <span class="string">"bcc"</span>) <span class="comment">#--&gt;插入指定位置。  </span></span><br><span class="line"></span><br><span class="line">names = names1 + names2 <span class="comment">#两个列表用连接符</span></span><br><span class="line">names1.extend(names2) <span class="comment">#扩充</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删</span></span><br><span class="line">names.pop() <span class="comment">#--&gt;删除最后一个；  </span></span><br><span class="line">names.remove(<span class="string">"lisi"</span>) <span class="comment">#--&gt;根据内容删除;  </span></span><br><span class="line"><span class="keyword">del</span> names[<span class="number">0</span>] <span class="comment">#--&gt;下标删除  </span></span><br><span class="line"><span class="comment">#改</span></span><br><span class="line">names[<span class="number">0</span>] = <span class="string">"abc"</span>  </span><br><span class="line"><span class="comment">#查</span></span><br><span class="line">name[<span class="number">1</span>:] <span class="comment"># "lisi"</span></span><br><span class="line"><span class="keyword">in</span>, <span class="keyword">not</span> <span class="keyword">in</span> <span class="comment">#是否存在 （if "zhangsan" in names:）  </span></span><br><span class="line"><span class="comment">#可以for... in 循环遍历</span></span><br><span class="line"></span><br><span class="line">len(names) <span class="comment">#元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：append添加的元素；extend连接的列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line"><span class="string">''</span>.join(list) <span class="comment"># 列表转字符串</span></span><br><span class="line">names.sort() <span class="comment">#排序，改变原结构; names.sort(reverse=True) 反向顺序</span></span><br></pre></td></tr></table></figure><p>运算符</p><table><thead><tr><th>表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>len([1, 2, 3])</td><td>3</td><td>计算元素个数</td></tr><tr><td>[1, 2, 3] + [4, 5, 6]</td><td>[1, 2, 3, 4, 5, 6]</td><td>连接</td></tr><tr><td>[‘Hi!’] * 4</td><td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>复制</td></tr><tr><td>3 in [1, 2, 3]</td><td>True</td><td>元素是否存在</td></tr><tr><td>for x in [1, 2, 3]: print(x, end=” “)</td><td>1 2 3</td><td>迭代</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;<span class="string">"server"</span>:<span class="string">"mpilgrim"</span>, <span class="string">"database"</span>:<span class="string">"master"</span>, <span class="string">"uid"</span>:<span class="string">"sa"</span>, <span class="string">"pwd"</span>:<span class="string">"secret"</span>&#125;</span><br><span class="line">[<span class="string">"%s=%s"</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> params.items()]</span><br><span class="line">[<span class="string">'server=mpilgrim'</span>, <span class="string">'uid=sa'</span>, <span class="string">'database=master'</span>, <span class="string">'pwd=secret'</span>]</span><br><span class="line"><span class="string">";"</span>.join([<span class="string">"%s=%s"</span> % (k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> params.items()])</span><br><span class="line"><span class="string">'server=mpilgrim;uid=sa;database=master;pwd=secret'</span></span><br></pre></td></tr></table></figure><h3 id="13-字典（可变）"><a href="#13-字典（可变）" class="headerlink" title="13.字典（可变）"></a>13.字典（可变）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">"name"</span>:<span class="string">"yy"</span>, <span class="string">"age"</span>: <span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#增</span></span><br><span class="line">a[<span class="string">"name"</span>] = <span class="string">"yy"</span> <span class="comment">#直接写key-value  </span></span><br><span class="line"><span class="comment">#删</span></span><br><span class="line"><span class="keyword">del</span> a[<span class="string">"name"</span>]</span><br><span class="line"><span class="comment">#改</span></span><br><span class="line">a[<span class="string">"name"</span>] = <span class="string">"zz"</span> <span class="comment">#相同key的值覆盖。</span></span><br><span class="line"><span class="comment">#查：</span></span><br><span class="line">a[<span class="string">"name"</span>], a.get(<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><p>for-else</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#for中没有break,则else一定会执行</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> strs:  </span><br><span class="line">   print(temp)    </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">   print(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>const 修改变量为不可变。<br>字典常见操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">len(a) <span class="comment">#键值对的个数</span></span><br><span class="line"></span><br><span class="line">a.keys() <span class="comment">#["name","age"] (pyhton2) #dict_keys(["name","age"])(pyhton3)返回key的列表</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"abc"</span> <span class="keyword">in</span> a.keys(): <span class="comment">#判断是否存在某个key</span></span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line">a.values() <span class="comment">#返回value的列表</span></span><br></pre></td></tr></table></figure><h3 id="14-元组-类似列表，不可变"><a href="#14-元组-类似列表，不可变" class="headerlink" title="14.元组(类似列表，不可变)"></a>14.元组(类似列表，不可变)</h3><p>列表可以增删改，元组不能改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (); <span class="comment">#空元组</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(tup1)     <span class="comment"># 不加逗号，类型为整型</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">&gt;&gt;&gt; tup1 = (50,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(tup1)     <span class="comment"># 加上逗号，类型为元组</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"tup1[0]: "</span>, tup1[<span class="number">0</span>]) <span class="comment"># Google</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"tup2[1:5]: "</span>, tup2[<span class="number">1</span>:<span class="number">5</span>]) <span class="comment">#(2, 3, 4, 5)</span></span><br></pre></td></tr></table></figure><p>修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>);</span><br><span class="line">tup2 = (<span class="string">'abc'</span>, <span class="string">'xyz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></span><br><span class="line"><span class="comment"># tup1[0] = 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2;</span><br><span class="line"><span class="keyword">print</span> (tup3) <span class="comment">#(12, 34.56, 'abc', 'xyz')</span></span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (tup)</span><br><span class="line"><span class="keyword">del</span> tup;</span><br></pre></td></tr></table></figure><p>运算符</p><table><thead><tr><th>表达式</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td>len((1, 2, 3))</td><td>3</td><td>计算元素个数</td></tr><tr><td>(1, 2, 3) + (4, 5, 6)</td><td>(1, 2, 3, 4, 5, 6)</td><td>连接</td></tr><tr><td>(‘Hi!’) * 4</td><td>(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td>复制</td></tr><tr><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td></tr><tr><td>for x in (1, 2, 3): print x,</td><td>1 2 3</td><td>迭代</td></tr></tbody></table><p>类似拆包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">11</span>,<span class="number">12</span>)</span><br><span class="line">b = a</span><br><span class="line">b <span class="comment">#out (11,12)</span></span><br><span class="line">c,d = a <span class="comment">#类似拆包</span></span><br><span class="line">c <span class="comment">#out 11</span></span><br><span class="line">d <span class="comment">#out 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line">info = &#123;<span class="string">"name"</span>:<span class="string">"ysw"</span>, <span class="string">"age"</span>:<span class="number">24</span>&#125;</span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> info:</span><br><span class="line">    print(temp)</span><br><span class="line"><span class="comment">#("name":"ysw")</span></span><br><span class="line"><span class="comment">#("age":24)</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> info.items():</span><br><span class="line">    print(<span class="string">"key=%s,value=%s"</span>%(temp[<span class="number">0</span>],temp[<span class="number">1</span>]))</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"><span class="keyword">for</span> a,b <span class="keyword">in</span> info.items():</span><br><span class="line">    print(<span class="string">"key=%s,value=%s"</span>%(a,b))</span><br></pre></td></tr></table></figure><p><strong>遍历技巧</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来</span></span><br><span class="line">knights = &#123;<span class="string">'gallahad'</span>: <span class="string">'the pure'</span>, <span class="string">'robin'</span>: <span class="string">'the brave'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span><br><span class="line">          print(k, v)</span><br><span class="line">          </span><br><span class="line">  <span class="comment">#gallahad the pure </span></span><br><span class="line">  <span class="comment">#robin the brave</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate([<span class="string">'tic'</span>, <span class="string">'tac'</span>, <span class="string">'toe'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br><span class="line"></span><br><span class="line"><span class="comment">#同时遍历两个或更多的序列，可以使用 zip() 组合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">'name'</span>, <span class="string">'quest'</span>, <span class="string">'favorite color'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answers = [<span class="string">'lancelot'</span>, <span class="string">'the holy grail'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> q, a <span class="keyword">in</span> zip(questions, answers):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'What is your &#123;0&#125;?  It is &#123;1&#125;.'</span>.format(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br><span class="line"></span><br><span class="line"><span class="comment">#要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> sorted(set(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure><h3 id="15-函数"><a href="#15-函数" class="headerlink" title="15.函数"></a>15.函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line">    </span><br><span class="line">abc()</span><br><span class="line"><span class="comment">#注意： 函数的定义需要在函数的调用之前，否则报错。</span></span><br></pre></td></tr></table></figure><p>可更改与不可更改对象：<br>在python中，strings,tuples和numbers是不可更改对象，list.dict等则是可更改对象。</p><ul><li>不可变类型：变量赋值 a=5后在赋值a=10,生成了新的对象，原对象丢弃。  </li><li>可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：  </p><ul><li>不可变类型:类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身</li><li>可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认函数参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( name, age = <span class="number">35</span> )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"名字: "</span>, name);</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"年龄: "</span>, age);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> );</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"------------------------"</span>)</span><br><span class="line">printinfo( name=<span class="string">"runoob"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">#名字:  runoob</span></span><br><span class="line"><span class="comment">#年龄:  50</span></span><br><span class="line"><span class="comment">#------------------------</span></span><br><span class="line"><span class="comment">#名字:  runoob</span></span><br><span class="line"><span class="comment">#年龄:  35</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( *vartuple )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="keyword">print</span> (var)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">printinfo(<span class="number">10</span>,<span class="number">32</span>,<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#匿名函数(lambda创建匿名函数)</span></span><br><span class="line"></span><br><span class="line">sum = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"相加后的值为 : "</span>, sum( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"相加后的值为 : "</span>, sum( <span class="number">20</span>, <span class="number">20</span> ))</span><br><span class="line"></span><br><span class="line"><span class="comment">#global关键字修改外部作用域变量</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 需要使用 global 关键字声明</span></span><br><span class="line">    print(num) </span><br><span class="line">    num = <span class="number">123</span></span><br><span class="line">    print(num)</span><br><span class="line">fun1()</span><br><span class="line"></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nonlocal 修改嵌套作用域变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num   <span class="comment"># nonlocal关键字声明</span></span><br><span class="line">        num = <span class="number">100</span></span><br><span class="line">        print(num)</span><br><span class="line">    inner()</span><br><span class="line">    print(num)</span><br><span class="line">outer()</span><br><span class="line"></span><br><span class="line"><span class="comment">#100</span></span><br><span class="line"><span class="comment">#100</span></span><br></pre></td></tr></table></figure><h3 id="16-迭代器和生成器"><a href="#16-迭代器和生成器" class="headerlink" title="16.迭代器和生成器"></a>16.迭代器和生成器</h3><p>字符串，列表和元组对象都可用于创建迭代器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)</span><br><span class="line">print(next(it)) <span class="comment">#1</span></span><br><span class="line">print(next(it)) <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#遍历</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    print(x, end = <span class="string">""</span>) <span class="comment"># 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(next(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></p><p>生成器(TODO: 待理解)<br>yield的函数，生成器是返回迭代器的函数，只能用于迭代操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> (next(f), end=<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br><span class="line"><span class="comment"># 0 1 1 2 3 5 8 13 21 34 55</span></span><br></pre></td></tr></table></figure></p><h3 id="17-模块"><a href="#17-模块" class="headerlink" title="17.模块"></a>17.模块</h3><p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。  </p><ul><li>import语句，想使用 Python 源文件，只需在另一个源文件里执行 import 语句。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: support.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">( par )</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"Hello : "</span>, par)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: test.py</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> support <span class="comment">#文件名</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 现在可以调用模块里包含的函数了</span></span><br><span class="line">support.print_func(<span class="string">"Runoob"</span>)</span><br></pre></td></tr></table></figure><ul><li>from…import语句,从模块中导入一个指定的部分到当前命名空间中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入模块 fibo 的 fib 函数</span></span><br><span class="line"><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br></pre></td></tr></table></figure><ul><li>From…import* 语句，把一个模块的所有内容全都导入到当前的命名空间。</li><li>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。</li><li><em>name</em>属性,一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行,可以用<strong>name</strong>属性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   print(<span class="string">'程序自身在运行'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">'我来自另一模块'</span>)</span><br></pre></td></tr></table></figure><ul><li>Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</li><li>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</li><li>推荐：from Package import specific_submodule</li></ul><h3 id="18-文件"><a href="#18-文件" class="headerlink" title="18.文件"></a>18.文件</h3><p>open()方法返回文件，第二个参数为文件打开方式。默认只读r。w写，a追加…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"/tmp/test.txt"</span>,<span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line">f.write(<span class="string">"人生苦短，我用python！"</span>)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><ul><li>f.read(size) 读取文件内容，size为空或负数则全部返回。</li><li>f.readline() f.readline() 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。</li><li>f.readlines() 读取文件所有行，并以列表返回。</li><li>f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。如果要写入一些不是字符串的东西, 那么将需要先进行转换。</li></ul><h3 id="19-类"><a href="#19-类" class="headerlink" title="19.类"></a>19.类</h3><ul><li>类方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="comment">#类方法必须有一个额外的第一个参数，惯例是self，不固定；代表的的类的实例而非类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line">x = MyClass()</span><br><span class="line">print(<span class="string">"MyClass 类的属性 i 为："</span>, x.i)</span><br><span class="line">print(<span class="string">"MyClass 类的方法 f 输出为："</span>, x.f())</span><br></pre></td></tr></table></figure><ul><li>构造方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>:</span></span><br><span class="line">    <span class="comment">#构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, realpart, imagpart)</span>:</span></span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line">x = Complex(<span class="number">3.0</span>, <span class="number">-4.5</span>)</span><br><span class="line">print(x.r, x.i)   <span class="comment"># 输出结果：3.0 -4.5</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">p = people(<span class="string">'runoob'</span>,<span class="number">10</span>,<span class="number">30</span>)</span><br><span class="line">p.speak()</span><br></pre></td></tr></table></figure><ul><li>继承</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁。"</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span><span class="params">(people)</span>:</span></span><br><span class="line">    grade = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g)</span>:</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 说: 我 %d 岁了，我在读 %d 年级"</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span><span class="params">()</span>:</span></span><br><span class="line">    topic = <span class="string">''</span></span><br><span class="line">    name = <span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,t)</span>:</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我叫 %s，我是一个演说家，我演讲的主题是 %s"</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span><span class="params">(speaker,student)</span>:</span></span><br><span class="line">    a =<span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n,a,w,g,t)</span>:</span></span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">"Tim"</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">"Python"</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br></pre></td></tr></table></figure><h3 id="20-正则表达式"><a href="#20-正则表达式" class="headerlink" title="20.正则表达式"></a>20.正则表达式</h3><ul><li>re.match与re.search的区别<br>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">line = <span class="string">"Cats are smarter than dogs"</span>;</span><br><span class="line"></span><br><span class="line">matchObj = re.match( <span class="string">r'dogs'</span>, line, re.M|re.I)</span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"match --&gt; matchObj.group() : "</span>, matchObj.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"No match!!"</span>)</span><br><span class="line"></span><br><span class="line">matchObj = re.search( <span class="string">r'dogs'</span>, line, re.M|re.I)</span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"search --&gt; matchObj.group() : "</span>, matchObj.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"No match!!"</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment">#No match!!</span></span><br><span class="line"><span class="comment">#search --&gt; matchObj.group() :  dogs</span></span><br></pre></td></tr></table></figure><ul><li>检索和替换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">phone = <span class="string">"2004-959-559 # 这是一个电话号码"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除注释</span></span><br><span class="line">num = re.sub(<span class="string">r'#.*$'</span>, <span class="string">""</span>, phone)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"电话号码 : "</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除非数字的内容</span></span><br><span class="line">num = re.sub(<span class="string">r'\D'</span>, <span class="string">""</span>, phone)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"电话号码 : "</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment">#电话号码 :  2004-959-559 </span></span><br><span class="line"><span class="comment">#电话号码 :  2004959559</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
